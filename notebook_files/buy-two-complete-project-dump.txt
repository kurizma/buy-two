# üöÄ Buy-Two Complete Project Dump
Generated: $(date)
Project Structure: Microservices (backend) + Angular (frontend) + API Tests
## üìÅ COMPLETE PROJECT STRUCTURE
```
Use 'tree' or 'dir /s'
```

## üê≥ DOCKER & START SCRIPTS

### docker-compose.yml
```
# version: '3.8'

x-common-env: &common-env
  EUREKA_CLIENT_SERVICE-URL-DEFAULTZONE: http://discovery-service:8761/eureka/
  SPRING_DATA_MONGODB_URI: ${ATLAS_URI}
  KAFKA_BOOTSTRAP_SERVERS: kafka:9092
  SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_SECRET: ${SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_SECRET}
  KEY_STORE_PASSWORD: ${KEY_STORE_PASSWORD} 

services:
  # === INFRA ===
  kafka:
    image: confluentinc/cp-kafka:7.6.1
    ports:
      - "9092:9092"
    environment:
      CLUSTER_ID: "5FpdX8jhTLOoQasxFvMBmg"
      KAFKA_PROCESS_ROLES: broker,controller
      KAFKA_NODE_ID: 1
      KAFKA_CONTROLLER_QUORUM_VOTERS: "1@kafka:9093"
      KAFKA_LISTENERS: "PLAINTEXT://:9092,CONTROLLER://:9093"
      KAFKA_ADVERTISED_LISTENERS: "PLAINTEXT://kafka:9092"
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: "PLAINTEXT:PLAINTEXT,CONTROLLER:PLAINTEXT"
      KAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
      KAFKA_NUM_PARTITIONS: 3
    volumes:
      - kafka_data:/var/lib/kafka/data

  # === DISCOVERY (starts first) ===
  discovery-service:
    build:
      context: ./backend/discovery-service
    image: discovery-service:${IMAGE_TAG:-latest}
    container_name: discovery-service-${IMAGE_TAG:-latest}
    ports: ["8761:8761"]
    env_file:
      - .env
    environment:
      SPRING_PROFILES_ACTIVE: docker
    volumes:
      - maven-repo:/root/.m2

  # === GATEWAY ===
  gateway-service:
    build: ./backend/gateway-service
    image: gateway-service:${IMAGE_TAG:-latest}
    container_name: gateway-service-${IMAGE_TAG:-latest}
    ports: ["8080:8080"]
    depends_on:
      - discovery-service
    env_file:
      - .env
    environment:
      <<: *common-env
      SERVER_PORT: 8080
    volumes:
      - maven-repo:/root/.m2

  # === BUSINESS SERVICES ===
  user-service:
    build: ./backend/user-service
    image: user-service:${IMAGE_TAG:-latest}
    container_name: user-service-${IMAGE_TAG:-latest}
    depends_on:
      - discovery-service
    env_file:
      - .env
    environment:
      <<: *common-env
      SPRING_DATA_MONGODB_DATABASE: ${USER_DB:-userdb}
      SERVER_PORT: 8456
    volumes:
      - maven-repo:/root/.m2

  product-service:
    build: ./backend/product-service
    image: product-service:${IMAGE_TAG:-latest}
    container_name: product-service-${IMAGE_TAG:-latest}
    depends_on:
      - discovery-service
      - kafka
    env_file:
      - .env
    environment:
      <<: *common-env
      SPRING_DATA_MONGODB_DATABASE: ${PRODUCT_DB:-productdb}
      SERVER_PORT: 8567
    volumes:
      - maven-repo:/root/.m2

  media-service:
    build: ./backend/media-service
    image: media-service:${IMAGE_TAG:-latest}
    container_name: media-service-${IMAGE_TAG:-latest}
    depends_on:
      - discovery-service
      - kafka
    env_file:
      - .env
    environment:
      <<: *common-env
      SPRING_DATA_MONGODB_DATABASE: ${MEDIA_DB:-mediadb}
      CLOUDFLARE_R2_ENDPOINT: ${R2_ENDPOINT}
      CLOUDFLARE_R2_ACCESS_KEY: ${R2_ACCESS_KEY}
      CLOUDFLARE_R2_SECRET_KEY: ${R2_SECRET_KEY}
      SERVER_PORT: 8678
    volumes:
      - maven-repo:/root/.m2

  order-service:
    build: ./backend/order-service
    image: order-service:${IMAGE_TAG:-latest}
    container_name: order-service-${IMAGE_TAG:-latest}
    ports: [ "8789:8789" ]
    depends_on:
      - discovery-service
      - kafka
    env_file:
      - .env
    environment:
      <<: *common-env
      SPRING_DATA_MONGODB_DATABASE: ${ORDER_DB:-orderdb}
      SERVER_PORT: 8789
    volumes:
      - maven-repo:/root/.m2

  # === FRONTEND ===
  frontend:
    build: ./frontend
    image: frontend:${IMAGE_TAG:-latest}
    container_name: frontend-${IMAGE_TAG:-latest}
    ports: ["4200:443"]
    depends_on: [gateway-service]

  # CRASH TEST (no build)
  # frontend:
  #   image: frontend:v999-broken-nonexistent
  #   container_name: frontend-v999-broken
  #   ports: ["4200:443"]
  #   depends_on: [gateway-service]

volumes:
  kafka_data:
  maven-repo:
```

### dump-script.sh
```
#!/bin/bash
OUTPUT="buy-two-complete-project-dump.txt"
echo "Generating PERFECT dump for Buy-Two project..."

> $OUTPUT

# HEADER
cat >> $OUTPUT << 'EOF'
# üöÄ Buy-Two Complete Project Dump
Generated: $(date)
Project Structure: Microservices (backend) + Angular (frontend) + API Tests
EOF

# 1. FULL PROJECT STRUCTURE
echo "## üìÅ COMPLETE PROJECT STRUCTURE" >> $OUTPUT
echo '```' >> $OUTPUT
tree -I 'node_modules|target|.git|build|.idea|*.log|notebook_files' -a >> $OUTPUT 2>/dev/null || echo "Use 'tree' or 'dir /s'" >> $OUTPUT
echo '```' >> $OUTPUT
echo "" >> $OUTPUT

# 2. DOCKER & START SCRIPTS
echo "## üê≥ DOCKER & START SCRIPTS" >> $OUTPUT
echo "" >> $OUTPUT
for file in docker-compose.yml *.sh .env; do
    if [ -f "$file" ]; then
        echo "### $file" >> $OUTPUT
        echo '```' >> $OUTPUT
        cat "$file" >> $OUTPUT
        echo '```' >> $OUTPUT
        echo "" >> $OUTPUT
    fi
done

# 3. ALL MICROSERVICES (backend/*)
echo "## üèóÔ∏è MICROSERVICES (6 Services)" >> $OUTPUT
echo "" >> $OUTPUT

SERVICES=("discovery-service" "gateway-service" "media-service" "order-service" "product-service" "user-service")

for SERVICE in "${SERVICES[@]}"; do
    if [ -d "backend/$SERVICE" ]; then
        echo "### üü¢ $SERVICE" >> $OUTPUT
        echo "" >> $OUTPUT
        
        # pom.xml
        if [ -f "backend/$SERVICE/pom.xml" ]; then
            echo "#### pom.xml" >> $OUTPUT
            echo '```xml' >> $OUTPUT
            cat "backend/$SERVICE/pom.xml" >> $OUTPUT
            echo '```' >> $OUTPUT
            echo "" >> $OUTPUT
        fi
        
        # application.yml
        for conf in "backend/$SERVICE/src/main/resources/application*.yml" "backend/$SERVICE/src/main/resources/application*.yaml" "backend/$SERVICE/src/main/resources/application*.properties"; do
            if [ -f "$conf" ]; then
                echo "#### $conf" >> $OUTPUT
                echo '```yaml' >> $OUTPUT
                cat "$conf" >> $OUTPUT
                echo '```' >> $OUTPUT
                echo "" >> $OUTPUT
            fi
        done
        
        # Controllers
        echo "#### Controllers" >> $OUTPUT
        find "backend/$SERVICE/src/main/java" -name "*Controller.java" -path "*/com/buyone/*" | sort | while read file; do
            echo "##### $(basename "$file")" >> $OUTPUT
            echo '```java' >> $OUTPUT
            cat "$file" >> $OUTPUT
            echo '```' >> $OUTPUT
            echo "" >> $OUTPUT
        done
        
        # Services
        echo "#### Services" >> $OUTPUT
        find "backend/$SERVICE/src/main/java" -name "*Service*.java" -path "*/com/buyone/*" | sort | while read file; do
            echo "##### $(basename "$file")" >> $OUTPUT
            echo '```java' >> $OUTPUT
            cat "$file" >> $OUTPUT
            echo '```' >> $OUTPUT
            echo "" >> $OUTPUT
        done
        
        # Repositories
        echo "#### Repositories" >> $OUTPUT
        find "backend/$SERVICE/src/main/java" -name "*Repository.java" -path "*/com/buyone/*" | sort | while read file; do
            echo "##### $(basename "$file")" >> $OUTPUT
            echo '```java' >> $OUTPUT
            cat "$file" >> $OUTPUT
            echo '```' >> $OUTPUT
            echo "" >> $OUTPUT
        done
        
        # Models/DTOs (top 10)
        echo "#### Models/DTOs (Top 10)" >> $OUTPUT
        find "backend/$SERVICE/src/main/java" \( -path "*/model/*" -o -path "*/dto/*" -o -path "*/entity/*" \) -name "*.java" | sort | head -10 | while read file; do
            echo "##### $(basename "$file")" >> $OUTPUT
            echo '```java' >> $OUTPUT
            cat "$file" >> $OUTPUT
            echo '```' >> $OUTPUT
            echo "" >> $OUTPUT
        done
        
        echo "---" >> $OUTPUT
        echo "" >> $OUTPUT
    fi
done

# 4. FRONTEND (Angular)
echo "## ‚öõÔ∏è FRONTEND (Angular)" >> $OUTPUT
echo "" >> $OUTPUT
echo "### package.json" >> $OUTPUT
echo '```json' >> $OUTPUT
cat frontend/package.json >> $OUTPUT 2>/dev/null || echo "No frontend/package.json" >> $OUTPUT
echo '```' >> $OUTPUT

echo "" >> $OUTPUT
echo "### angular.json (key parts)" >> $OUTPUT
grep -A 20 -B 5 '"projects"' frontend/angular.json >> $OUTPUT 2>/dev/null || echo "No angular.json details" >> $OUTPUT

# 5. API TESTS (Bruno)
echo "## üß™ API TESTS (Bruno)" >> $OUTPUT
echo "" >> $OUTPUT
if [ -f "bruno/buy-two-api/bruno.json" ]; then
    echo "### bruno.json" >> $OUTPUT
    echo '```json' >> $OUTPUT
    head -100 "bruno/buy-two-api/bruno.json" >> $OUTPUT  # First 100 lines
    echo '```' >> $OUTPUT
fi

# 6. INFRA & DOCS
echo "## üèóÔ∏è INFRA & DOCUMENTATION" >> $OUTPUT
echo "" >> $OUTPUT
for file in README.md B02-Task.md POSTMAN_TESTING_GUIDE.md docker-compose.yml Jenkinsfile; do
    if [ -f "$file" ]; then
        echo "### $file" >> $OUTPUT
        echo '```' >> $OUTPUT
        head -200 "$file" >> $OUTPUT  # First 200 lines
        echo '```' >> $OUTPUT
        echo "" >> $OUTPUT
    fi
done

echo "## ‚úÖ COMPLETE DUMP READY" >> $OUTPUT
echo "Upload to NotebookLM/Perplexity for analysis" >> $OUTPUT

echo "‚úÖ Generated: $OUTPUT ($(du -h $OUTPUT | cut -f1))"
```

### start-app.sh
```
#!/usr/bin/env bash

./start-frontend.sh &
./start-backend.sh &

wait



#chmod +x start-app.sh
#chmod +x start-frontend.sh
#chmod +x start-backend.sh

# chmod +x start-app.sh

```

### start-backend.sh
```
#!/usr/bin/env bash
set -e
trap "echo 'Stopping all services...'; kill 0" EXIT

wait_for_http() {
  local url=$1
  local name=$2
  echo "Waiting for $name at $url ..."
  for i in {1..60}; do
    if curl -k -sSf "$url" >/dev/null 2>&1; then
      echo "$name is up."
      return 0
    fi
    sleep 1
  done
  echo "ERROR: $name did not start in time."
  return 1
}

start_service_script() {
  local script_path=$1
  echo "Starting via $script_path ..."
  "$script_path" &
}

cd backend

echo "============================"
# 1. discovery-service :8761
start_service_script "./discovery-service/start.sh"

wait_for_http "http://localhost:8761/eureka/apps" "discovery-service" || exit 1

# 2. gateway-service :8080
start_service_script "./gateway-service/start.sh"
wait_for_http "https://localhost:8080/actuator/health" "gateway-service" || exit 1

# 3. user-service :8456
start_service_script "./user-service/start.sh"
wait_for_http "http://localhost:8456/actuator/health" "user-service" || exit 1

# 4. product-service :8567
start_service_script "./product-service/start.sh"
wait_for_http "http://localhost:8567/actuator/health" "product-service" || exit 1

# 5. media-service :8678
start_service_script "./media-service/start.sh"
wait_for_http "http://localhost:8678/actuator/health" "media-service" || exit 1

# 5. order-service :8789
start_service_script "./order-service/start.sh"
wait_for_http "http://localhost:8789/actuator/health" "order-service" || exit 1

cd ..

wait

# chmod +x start-backend.sh && ./start-backend.sh```

### start-frontend.sh
```
#!/usr/bin/env bash
set -e

cd frontend

echo "Frontend version: $(node -p "require('./package.json').version")"
echo "Node version: $(node -v)"
echo "npm version:  $(npm -v)"

npm ci
echo "Starting frontend..."
NG_CLI_ANALYTICS=false npm start

# chmod +x start-frontend.sh && ./start-frontend.sh
```

### stop-app.sh
```
#!/usr/bin/env bash
set -e

PORTS="8761 8080 8456 8567 8678 4200"

for p in $PORTS; do
  pids=$(lsof -ti :$p || true)
  if [ -n "$pids" ]; then
    for pid in $pids; do
      echo "Sending SIGTERM to PID $pid on port $p"
      kill "$pid" || true
    done
  fi
done

# Wait a bit for graceful shutdown
sleep 5

# Force kill anything still left on those ports
for p in $PORTS; do
  pids=$(lsof -ti :$p || true)
  if [ -n "$pids" ]; then
    for pid in $pids; do
      echo "PID $pid on port $p still alive, sending SIGKILL"
      kill -9 "$pid" || true
    done
  fi
done
```

### .env
```
# Your Atlas connection string
ATLAS_URI="mongodb+srv://Cluster05093:.qwe.qwe.qwe@cluster05093.dh3rmhg.mongodb.net/buy-one?retryWrites=true&w=majority&appName=Cluster05093"

# Individual DB names (Atlas creates on first write)
USER_DB=buy-one
PRODUCT_DB=buy-one
MEDIA_DB=buy-one

# R2 (Media Service)
R2_ENDPOINT=https://ed2494a6dd015fe932f0eb26102d514d.r2.cloudflarestorage.com/buyone-images
R2_ACCESS_KEY=98633bbe85642d122cbdc482bedd7c33
R2_SECRET_KEY=d6ebfdcba1a5136a4bcaa047f40527ef71bdcc6333f8d2e9823c331541918cac

# key-store password
KEY_STORE_PASSWORD=buy0ne

# Spring security user 
SPRING_SECURITY_USER_NAME=user
SPRING_SECURITY_USER_PASSWORD=password

# Security Password OAuth
SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_SECRET=oogabooga123oogabooga123oogabooga123!```

## üèóÔ∏è MICROSERVICES (6 Services)

### üü¢ discovery-service

#### pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.8</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.buyone</groupId>
    <artifactId>discovery-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Discovery Service</name>
    <description>Eureka Discovery Service for buy-one Platform microservice registry</description>

    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2022.0.5</spring-cloud.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### Controllers
#### Services
##### DiscoveryServiceApplication.java
```java
package com.buyone.discovery_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class DiscoveryServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(DiscoveryServiceApplication.class, args);
	}

}
```

#### Repositories
#### Models/DTOs (Top 10)
---

### üü¢ gateway-service

#### pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.8</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.buyone</groupId>
    <artifactId>gateway-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Gateway Service</name>
    <description>Spring Cloud Gateway API Gateway for buy-one platform</description>

    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2022.0.5</spring-cloud.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### Controllers
#### Services
##### GatewayServiceApplication.java
```java
package com.buyone.gatewayservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class GatewayServiceApplication {
 
	public static void main(String[] args) {
		SpringApplication.run(GatewayServiceApplication.class, args);
	}

}
```

#### Repositories
#### Models/DTOs (Top 10)
---

### üü¢ media-service

#### pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.1.8</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.buyone</groupId>
	<artifactId>media-service</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>Media Service</name>
	<description>Managing media (images) for products in buy-one</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2022.0.5</spring-cloud.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka</artifactId>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<version>1.18.30</version>
            <scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
        <dependency>
            <groupId>software.amazon.awssdk</groupId>
            <artifactId>s3</artifactId>
            <version>2.17.123</version>
        </dependency>
	</dependencies>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.11.0</version>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
							<version>1.18.30</version>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
```

#### Controllers
##### MediaController.java
```java
package com.buyone.mediaservice.controller;

import com.buyone.mediaservice.model.Media;
import com.buyone.mediaservice.request.MediaUploadRequest;
import com.buyone.mediaservice.response.MediaResponse;
import com.buyone.mediaservice.response.MediaListResponse;
import com.buyone.mediaservice.response.DeleteMediaResponse;
import com.buyone.mediaservice.response.ApiResponse;
import com.buyone.mediaservice.service.MediaService;
import com.buyone.mediaservice.service.StorageService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.http.ResponseEntity;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;

import java.util.List;

@RestController
@RequestMapping("/media/images")
@RequiredArgsConstructor
public class MediaController {
    
    private final MediaService mediaService;
    private final StorageService storageService;
    // use @Value or service constant and put into yml
    private static final int MAX_IMAGES_PER_PRODUCT = 5;
    
    @GetMapping("/product/{productId}")
    public ResponseEntity<ApiResponse<MediaListResponse>> listMediaForProduct(@PathVariable String productId) {
        List<MediaResponse> responses = mediaService.mediaListForProduct(productId);
        MediaListResponse payload = new MediaListResponse(responses, responses.size(), MAX_IMAGES_PER_PRODUCT);
        ApiResponse<MediaListResponse> response = ApiResponse.<MediaListResponse>builder()
                .success(true)
                .data(payload)
                .build();
        return ResponseEntity.ok(response);
    }
    
    //    Right now, your getMedia is perfect for APIs (Angular) to fetch metadata,
    //    but to actually display the avatar image in <img>,
    //    you‚Äôll eventually need an endpoint that returns image/jpeg bytes.
    //    For now, conceptually:
    //    Yes: GET /media/images/{mediaId} is the avatar metadata call.
    
    // get metadata for specific media file, ex. Avatar
    @GetMapping("/{mediaId}")
    public ResponseEntity<ApiResponse<MediaResponse>> getMedia(@PathVariable String mediaId) {
        MediaResponse media = mediaService.getMedia(mediaId);
        ApiResponse<MediaResponse> response = ApiResponse.<MediaResponse>builder()
                .success(true)
                .data(media)
                .build();
        return ResponseEntity.ok(response);
    }
    
    // raw image api
    @GetMapping("/{mediaId}/file")
    public ResponseEntity<Resource> getImageFile(@PathVariable String mediaId) {
        Media media = mediaService.findMediaEntity(mediaId); // or reuse getMedia + repo
        Resource resource = storageService.loadAsResource(media.getImagePath());
        
        return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_JPEG) // or detect from file/metadata
                .body(resource);
    }
    
    
    
    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<ApiResponse<MediaResponse>> uploadImage(
            @Valid @ModelAttribute MediaUploadRequest request,
            @RequestHeader("X-USER-ID") String currentUserId,
            @RequestHeader("X-USER-ROLE") String currentUserRole
    ) {
        MediaResponse media = mediaService.uploadImage(
                request.getFile(),
                request.getOwnerId(),
                request.getOwnerType(),
                currentUserId,
                currentUserRole
        );
        ApiResponse<MediaResponse> response = ApiResponse.<MediaResponse>builder()
                .success(true)
                .message("Image uploaded successfully")
                .data(media)
                .build();
        return ResponseEntity.status(201).body(response);
    }
    
    @PutMapping(value = "/{mediaId}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<ApiResponse<MediaResponse>> updateMedia(
            @PathVariable String mediaId,
            @RequestParam("file") MultipartFile file,
            @RequestHeader("X-USER-ID") String currentUserId,
            @RequestHeader("X-USER-ROLE") String currentUserRole
    ) {
        MediaResponse media = mediaService.updateMedia(file, mediaId, currentUserId, currentUserRole);
        ApiResponse<MediaResponse> response = ApiResponse.<MediaResponse>builder()
                .success(true)
                .message("Image updated successfully")
                .data(media)
                .build();
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{mediaId}")
    public ResponseEntity<ApiResponse<DeleteMediaResponse>>  deleteMedia(@PathVariable String mediaId,
            @RequestHeader("X-USER-ID") String currentUserId,
            @RequestHeader("X-USER-ROLE") String currentUserRole
    ) {
        DeleteMediaResponse deleted = mediaService.deleteMedia(mediaId, currentUserId, currentUserRole);
        ApiResponse<DeleteMediaResponse> response = ApiResponse.<DeleteMediaResponse>builder()
                .success(true)
                .message("Deleted successfully")
                .data(deleted)
                .build();
        return ResponseEntity.ok(response);
    }
}
```

#### Services
##### MediaServiceApplication.java
```java
package com.buyone.mediaservice;

import org.springframework.boot.SpringApplication;
import com.buyone.mediaservice.config.CloudflareR2Properties;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@SpringBootApplication
@EnableConfigurationProperties(CloudflareR2Properties.class)
public class MediaServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(MediaServiceApplication.class, args);
	}

}
```

##### MediaServiceImpl.java
```java
package com.buyone.mediaservice.service.impl; 

import com.buyone.mediaservice.model.Media;
import com.buyone.mediaservice.model.MediaOwnerType;
import com.buyone.mediaservice.repository.MediaRepository;
import com.buyone.mediaservice.response.MediaResponse;
import com.buyone.mediaservice.response.DeleteMediaResponse;
import com.buyone.mediaservice.service.MediaService;
import com.buyone.mediaservice.service.StorageService;
import com.buyone.mediaservice.exception.MediaNotFoundException;
import com.buyone.mediaservice.exception.InvalidFileException;
import com.buyone.mediaservice.exception.ConflictException;
import com.buyone.mediaservice.exception.ForbiddenException;
import lombok.RequiredArgsConstructor;

import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.beans.factory.annotation.Value;

import java.time.Instant;
import java.util.List;

@Service
@RequiredArgsConstructor
public class MediaServiceImpl implements MediaService {
    
    private final MediaRepository mediaRepository;
    private final StorageService storageService;
    
    private static final int MAX_IMAGES_PER_PRODUCT = 5;
    private static final long MAX_FILE_SIZE_BYTES = 2L * 1024 * 1024;

    @Value("${app.media.public-base-url}")
    private String publicBucketBaseUrl;
    
    @Override
    public MediaResponse uploadImage(MultipartFile file,
                                    String ownerId,
                                    MediaOwnerType ownerType,
                                    String currentUserId,
                                    String currentUserRole) {
        validateImageFile(file);
        boolean isSeller = "SELLER".equals(currentUserRole);
        boolean isClient = "CLIENT".equals(currentUserRole);

        // For USER avatars: allow both SELLER and CLIENT,
        //    but only for their own user id
        if (ownerType == MediaOwnerType.USER) {
            if (!(isSeller || isClient)) {
                throw new ForbiddenException("Only Sellers and Clients can upload user avatars.");
            }
            if (!ownerId.equals(currentUserId)) {
                throw new ForbiddenException("You can only upload an avatar for yourself.");
            }
        }
        // For PRODUCT images: only SELLER role allowed
        if (ownerType == MediaOwnerType.PRODUCT && !isSeller) {
            throw new ForbiddenException("Only Seller can upload product images.");
        }

        // If this is a user avatar, ensure only one avatar per user
        if (ownerType == MediaOwnerType.USER) {
            List<Media> existingAvatar = mediaRepository.findAllByOwnerIdAndOwnerType(ownerId, MediaOwnerType.USER);
            for (Media m : existingAvatar) {
                storageService.delete(m.getImagePath());
                mediaRepository.delete(m);
            }
        }

        // If this is a product image, enforce max 5 images per product
        if (ownerType == MediaOwnerType.PRODUCT) {
            long imageCount = mediaRepository.countByOwnerIdAndOwnerType(ownerId, MediaOwnerType.PRODUCT);
            if (imageCount >= MAX_IMAGES_PER_PRODUCT) {
                throw new ConflictException("This product already has the maximum number of images (" + MAX_IMAGES_PER_PRODUCT + ").");
            }
        }
    
        
        Media media = Media.builder()
                .ownerId(ownerId)
                .ownerType(ownerType)
                .createdAt(Instant.now())
                .build();
        
        media = mediaRepository.save(media);
        
        // store() should return something like "media/<id>.png"
        String imagePath = storageService.store(file, media.getId());
        
        media.setImagePath(imagePath);
        media = mediaRepository.save(media);
        
        // Public Cloudflare URL, e.g. https://pub-....r2.dev/media/<id>.png
        String url = publicBucketBaseUrl + "/" + imagePath;
        
        return new MediaResponse(
                media.getId(),
                media.getOwnerId(),
                url,
                media.getCreatedAt()
        );
    }
    
    @Override
    public MediaResponse getMedia(String id) {
        Media media = mediaRepository.findById(id)
                .orElseThrow(() -> new MediaNotFoundException(id));
        // Public Cloudflare URL, e.g. https://pub-....r2.dev/media/<id>.png
        String url = publicBucketBaseUrl + "/" + media.getImagePath();
        return new MediaResponse(
                media.getId(),
                media.getOwnerId(),
                url,
                media.getCreatedAt()
        );
    }
    
    @Override
    public MediaResponse updateMedia(MultipartFile file,
                                    String mediaId,
                                    String currentUserId,
                                    String currentUserRole) {
        validateImageFile(file);
        
        if (!"SELLER".equals(currentUserRole)) {
            throw new ForbiddenException("Only sellers can update images.");
        }
        
        Media media = mediaRepository.findById(mediaId)
                .orElseThrow(() -> new MediaNotFoundException(mediaId));
        
        // Ownership: only ownerId can update this media
        if (!media.getOwnerId().equals(currentUserId)) {
            throw new ForbiddenException("You can only update your own media.");
        }
        
        
        storageService.delete(media.getImagePath());
        
        String newImagePath = storageService.store(file, media.getId());
        
        media.setImagePath(newImagePath);
        media.setCreatedAt(Instant.now());
        
        media = mediaRepository.save(media);
        
        // Public Cloudflare URL, e.g. https://pub-....r2.dev/media/<id>.png
        String url = publicBucketBaseUrl + "/" + newImagePath;
        
        return new MediaResponse(
                media.getId(),
                media.getOwnerId(),
                url,
                media.getCreatedAt()
        );
    }
    
    @Override
    public DeleteMediaResponse deleteMedia(String id,
                                        String currentUserId,
                                        String currentUserRole) {
        boolean isSeller = "SELLER".equals(currentUserRole);
        boolean isClient = "CLIENT".equals(currentUserRole);

        Media media = mediaRepository.findById(id)
                .orElseThrow(() -> new MediaNotFoundException(id));

        // USER avatars: owner can delete their own avatar (CLIENT or SELLER)
        if (media.getOwnerType() == MediaOwnerType.USER) {
            if (!media.getOwnerId().equals(currentUserId)) {
                throw new ForbiddenException("You can only delete your own avatar.");
            }
            if (!(isSeller || isClient)) {
                throw new ForbiddenException("Only Sellers or Clients can delete user avatars.");
            }   
        }

        // PRODUCT images: only SELLER allowed, and must be owner
        if (media.getOwnerType() == MediaOwnerType.PRODUCT) {
            if (!isSeller) {
                throw new ForbiddenException("Only sellers can delete product images.");
            }
            if (!media.getOwnerId().equals(currentUserId)) {
                throw new ForbiddenException("You can only delete your own product images.");
            }
        }

        // if (!"SELLER".equals(currentUserRole)) {
        //     throw new ForbiddenException("Only sellers can delete images.");
        // }
        
        // ‚úÖ CRITICAL: Ownership check FIRST
        // if (!media.getOwnerId().equals(currentUserId)) {
        //     throw new ForbiddenException("You can only delete your own media.");
        // }
        
        // ‚úÖ Role check: CLIENT can delete OWN avatar, SELLER can delete anything
        // if (media.getOwnerType() == MediaOwnerType.USER && !"SELLER".equals(currentUserRole)) {
        //     throw new ForbiddenException("Only sellers can manage user avatars.");
        // }
        
        storageService.delete(media.getImagePath());
        mediaRepository.deleteById(id);
        return new DeleteMediaResponse(id, "Deleted successfully");
    }
    
    @Override
    public List<MediaResponse> mediaListForProduct(String productId) {
        List<Media> medias = mediaRepository.findAllByOwnerIdAndOwnerType(productId, MediaOwnerType.PRODUCT);
        
        return medias.stream()
                .map(m -> new MediaResponse(
                        m.getId(),
                        m.getOwnerId(),
                        publicBucketBaseUrl + "/" + m.getImagePath(),
                        m.getCreatedAt()
                ))
                .toList();
    }
    
    @Override
    public Media findMediaEntity(String id) {
        return mediaRepository.findById(id)
                .orElseThrow(() -> new MediaNotFoundException(id));
    }
    
    private void validateImageFile(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            throw new InvalidFileException("No file provided!");
        }
        if (file.getSize() > MAX_FILE_SIZE_BYTES) {
            throw new InvalidFileException("File exceeds 2MB size limit!");
        }
        String contentType = file.getContentType();
        if (contentType == null || !contentType.startsWith("image/")) {
            throw new InvalidFileException("Only image files are allowed!");
        }
    }
}
```

##### StorageServiceImpl.java
```java
package com.buyone.mediaservice.service.impl;

import com.buyone.mediaservice.config.CloudflareR2Properties;
import com.buyone.mediaservice.exception.InvalidFileException;
import com.buyone.mediaservice.exception.MediaNotFoundException;
import com.buyone.mediaservice.exception.BadRequestException;
import com.buyone.mediaservice.service.StorageService;
import com.buyone.mediaservice.config.CloudflareR2Properties;
import lombok.RequiredArgsConstructor;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import software.amazon.awssdk.core.ResponseInputStream;
import software.amazon.awssdk.core.sync.RequestBody;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.DeleteObjectRequest;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.GetObjectResponse;
import software.amazon.awssdk.services.s3.model.NoSuchKeyException;
import software.amazon.awssdk.services.s3.model.PutObjectRequest;

import java.io.ByteArrayInputStream;
import java.io.IOException;

@Service
@RequiredArgsConstructor
public class StorageServiceImpl implements StorageService {
    
    private final S3Client r2S3Client;
    private final CloudflareR2Properties props;
    
    @Override
    public String store(MultipartFile file, String mediaId) {
        if (file.isEmpty()) {
            throw new BadRequestException("Cannot store empty file");
        }
        
        long maxBytes = 2L * 1024 * 1024;
        if (file.getSize() > maxBytes) {
            throw new InvalidFileException("File too large, max 2MB");
        }
        
        if (file.getContentType() == null || !file.getContentType().startsWith("image/")) {
            throw new InvalidFileException("Only image/* uploads are allowed");
        }
        
        String originalFilename = file.getOriginalFilename();
        String extension = "";
        if (originalFilename != null && originalFilename.contains(".")) {
            extension = originalFilename.substring(originalFilename.lastIndexOf('.'));
        }
        String key = "media/" + mediaId + extension;
        
        try {
            PutObjectRequest putReq = PutObjectRequest.builder()
                    .bucket(props.getBucket())
                    .key(key)
                    .contentType(file.getContentType())
                    .build();
            
            r2S3Client.putObject(putReq, RequestBody.fromBytes(file.getBytes()));
            return key;
        } catch (IOException e) {
            throw new InvalidFileException("Failed to read uploaded file", e);
        } catch (Exception e) {
            // Any AWS/R2 error while putting object ‚Üí 500 via global handler
            throw new RuntimeException("Failed to store file in R2", e);
        }
    }
    
    @Override
    public Resource loadAsResource(String imagePath) {
        try {
            GetObjectRequest getReq = GetObjectRequest.builder()
                    .bucket(props.getBucket())
                    .key(imagePath)
                    .build();
            
            ResponseInputStream<GetObjectResponse> s3Object =
                    r2S3Client.getObject(getReq);
            
            byte[] bytes = s3Object.readAllBytes();
            return new InputStreamResource(new ByteArrayInputStream(bytes));
        } catch (NoSuchKeyException e) {
            throw new MediaNotFoundException(imagePath);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read object from R2", e);
        }
    }
    
    @Override
    public void delete(String imagePath) {
        try {
            DeleteObjectRequest delReq = DeleteObjectRequest.builder()
                    .bucket(props.getBucket())
                    .key(imagePath)
                    .build();
            r2S3Client.deleteObject(delReq);
        } catch (NoSuchKeyException e) {
            // Up to you: either ignore or signal 404
            throw new MediaNotFoundException(imagePath);
        }
    }
}
```

##### MediaService.java
```java
package com.buyone.mediaservice.service;

import com.buyone.mediaservice.model.Media;
import com.buyone.mediaservice.model.MediaOwnerType;
import com.buyone.mediaservice.response.MediaResponse;
import com.buyone.mediaservice.response.MediaListResponse;
import com.buyone.mediaservice.response.DeleteMediaResponse;
import org.springframework.web.multipart.MultipartFile;
import java.util.List;

public interface MediaService {
    MediaResponse uploadImage(MultipartFile file,
                              String ownerId,
                              MediaOwnerType ownerType,
                              String currentUserId,
                              String currentUserRole);
    
    MediaResponse getMedia(String id);
    
    MediaResponse updateMedia(MultipartFile file,
                              String mediaId,
                              String currentUserId,
                              String currentUserRole);
    
    DeleteMediaResponse deleteMedia(String id,
                                    String currentUserId,
                                    String currentUserRole);
    
    List<MediaResponse> mediaListForProduct(String productId);
    
    // calling from storage to media
    Media findMediaEntity(String id);
}
```

##### StorageService.java
```java
package com.buyone.mediaservice.service;

import org.springframework.core.io.Resource;
import org.springframework.web.multipart.MultipartFile;

public interface StorageService {
    
    String store(MultipartFile file, String mediaId);
    
    Resource loadAsResource(String imagePath);
    
    void delete(String imagePath);
}
```

#### Repositories
##### MediaRepository.java
```java
package com.buyone.mediaservice.repository;

import com.buyone.mediaservice.model.Media;
import com.buyone.mediaservice.model.MediaOwnerType;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.List;

public interface MediaRepository extends MongoRepository<Media, String> {
    long countByOwnerIdAndOwnerType(String ownerId, MediaOwnerType ownerType);
    List<Media> findAllByOwnerIdAndOwnerType(String ownerId, MediaOwnerType ownerType);
}
```

#### Models/DTOs (Top 10)
##### Media.java
```java
package com.buyone.mediaservice.model;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Document("media")
public class Media {
    
    @Id
    private String id;
    private String ownerId; // userId or productId
    private MediaOwnerType ownerType; // USER or PRODUCT
    private String imagePath;   // where the file is stored (relative path or URL)
    
    @CreatedDate
    private Instant createdAt;
}
```

##### MediaOwnerType.java
```java
package com.buyone.mediaservice.model;

public enum MediaOwnerType {
    USER,
    PRODUCT
}
```

---

### üü¢ order-service

#### pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.1.8</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.buyone</groupId>
	<artifactId>order-service</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>Product Service</name>
	<description>Managing product catalog operations for buy-one</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2022.0.5</spring-cloud.version>
	</properties>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka</artifactId>
		</dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
			<version>1.18.30</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-ui</artifactId>
            <version>1.7.0</version>
        </dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka-test</artifactId>
			<scope>test</scope>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
	</dependencies>


	<build>
		<plugins>
            <!-- Maven Compiler Plugin for Lombok support -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
				<version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
							<version>1.18.30</version>
                        </path>
                    </annotationProcessorPaths>
                    <release>${java.version}</release>
                </configuration>
            </plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>
```

#### Controllers
##### AnalyticsController.java
```java
package com.buyone.orderservice.controller;

import com.buyone.orderservice.dto.response.ApiResponse;
import com.buyone.orderservice.dto.response.analytics.ClientAnalyticsResponse;
import com.buyone.orderservice.dto.response.analytics.SellerAnalyticsResponse;
import com.buyone.orderservice.service.ProfileAnalyticsService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/analytics")
@RequiredArgsConstructor
public class AnalyticsController {
    
    private final ProfileAnalyticsService profileAnalyticsService;
    
    @GetMapping("/client/{clientId}")
    public ResponseEntity<ApiResponse<ClientAnalyticsResponse>> getClientAnalytics(
            @PathVariable String clientId) {
        ClientAnalyticsResponse analytics = profileAnalyticsService.getClientAnalytics(clientId);
        return ResponseEntity.ok(ApiResponse.<ClientAnalyticsResponse>builder()
                .success(true)
                .message("Client analytics fetched successfully")
                .data(analytics)
                .build());
    }
    
    @GetMapping("/seller/{sellerId}")
    public ResponseEntity<ApiResponse<SellerAnalyticsResponse>> getSellerAnalytics(
            @PathVariable String sellerId) {
        SellerAnalyticsResponse analytics = profileAnalyticsService.getSellerAnalytics(sellerId);
        return ResponseEntity.ok(ApiResponse.<SellerAnalyticsResponse>builder()
                .success(true)
                .message("Seller analytics fetched successfully")
                .data(analytics)
                .build());
    }
}
```

##### CartController.java
```java
package com.buyone.orderservice.controller;

import com.buyone.orderservice.dto.response.ApiResponse;
import com.buyone.orderservice.model.cart.Cart;
import com.buyone.orderservice.model.cart.CartItem;
import com.buyone.orderservice.service.CartService;
import com.buyone.orderservice.exception.BadRequestException;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/api/cart")
@RequiredArgsConstructor
@Slf4j
public class CartController {
    
    private static final String CLIENT_ROLE = "CLIENT";
    private final CartService cartService;
    
    @PostMapping("/items")
    @Operation(summary = "Add item to cart", description = "Merge if same product+seller")
    public ResponseEntity<ApiResponse<Cart>> addItem(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role,
            @Valid @RequestBody CartItem item) {
        validateRole(role, CLIENT_ROLE);
        log.debug("Adding item to cart for user: {}", userId);
        Cart cart = cartService.addItem(userId, item);
        return ResponseEntity.ok(ApiResponse.<Cart>builder()
                .success(true)
                .message("Item added to cart successfully")
                .data(cart)
                .build());
    }
    
    @GetMapping
    @Operation(summary = "Get current cart")
    public ResponseEntity<ApiResponse<Optional<Cart>>> getCart(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, CLIENT_ROLE);
        Optional<Cart> cartOpt = cartService.getCart(userId);
        if (cartOpt.isEmpty()) {
            return ResponseEntity.ok(ApiResponse.<Optional<Cart>>builder()
                    .success(true)
                    .message("Cart is empty")
                    .data(Optional.empty())
                    .build());
        }
        return ResponseEntity.ok(ApiResponse.<Optional<Cart>>builder()
                .success(true)
                .message("Cart fetched successfully")
                .data(cartOpt)
                .build());
    }
    
    @PutMapping("/items/{productId}/quantity/{quantity}")
    @Operation(summary = "Update item quantity")
    public ResponseEntity<ApiResponse<Cart>> updateQuantity(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role,
            @PathVariable String productId,
            @PathVariable int quantity) {
        validateRole(role, CLIENT_ROLE);
        Cart cart = cartService.updateQuantity(userId, productId, quantity);
        return ResponseEntity.ok(ApiResponse.<Cart>builder()
                .success(true)
                .message("Item quantity updated successfully")
                .data(cart)
                .build());
    }
    
    @DeleteMapping("/items/{productId}")
    @Operation(summary = "Remove item from cart")
    public ResponseEntity<ApiResponse<Void>> removeItem(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role,
            @PathVariable String productId) {
        validateRole(role, CLIENT_ROLE);
        cartService.removeItem(userId, productId);
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("Item removed from cart successfully")
                .build());
    }
    
    @DeleteMapping
    @Operation(summary = "Clear entire cart")
    public ResponseEntity<ApiResponse<Void>> clearCart(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, CLIENT_ROLE);
        cartService.clearCart(userId);
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("Cart cleared successfully")
                .build());
    }
    
    private void validateRole(String role, String requiredRole) {
        if (!requiredRole.equals(role)) {
            throw new BadRequestException("Required role: " + requiredRole + ", got: " + role);
        }
    }
}
```

##### OrderController.java
```java
package com.buyone.orderservice.controller;

import com.buyone.orderservice.dto.request.order.CreateOrderRequest;
import com.buyone.orderservice.dto.request.order.OrderSearchRequest;
import com.buyone.orderservice.dto.response.ApiResponse;
import com.buyone.orderservice.dto.response.order.OrderResponse;
import com.buyone.orderservice.dto.response.order.OrderItemResponse;
import com.buyone.orderservice.model.order.Order;
import com.buyone.orderservice.model.order.OrderStatus;
import com.buyone.orderservice.service.OrderService;
import com.buyone.orderservice.exception.BadRequestException;
import io.swagger.v3.oas.annotations.Operation;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
@Slf4j
public class OrderController {
    
    private final OrderService orderService;
    
    @PostMapping("/checkout")
    @Operation(summary = "Create order from cart", description = "Pay on Delivery")
    public ResponseEntity<ApiResponse<OrderResponse>> createOrderFromCart(
            @Valid @RequestBody CreateOrderRequest req,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        log.info("Client {} checking out with address", userId);
        Order order = orderService.createOrderFromCart(userId, req.getShippingAddress());
        OrderResponse orderResp = mapToOrderResponse(order);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.<OrderResponse>builder()
                        .success(true)
                        .message("Order created successfully")
                        .data(orderResp)
                        .build());
    }
    
    @GetMapping("/buyer")
    @Operation(summary = "Get buyer orders")
    public ResponseEntity<ApiResponse<List<OrderResponse>>> getBuyerOrders(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        List<OrderResponse> orders = orderService.getBuyerOrders(userId)
                .stream()
                .map(this::mapToOrderResponse)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.<List<OrderResponse>>builder()
                .success(true)
                .message("Buyer orders fetched successfully")
                .data(orders)
                .build());
    }
    
    @GetMapping("/{orderNumber}")
    @Operation(summary = "Get order details")
    public ResponseEntity<ApiResponse<OrderResponse>> getOrder(@PathVariable String orderNumber) {
        OrderResponse order = orderService.getOrder(orderNumber)
                .map(this::mapToOrderResponse)
                .orElseThrow(() -> new BadRequestException("Order not found: " + orderNumber));
        return ResponseEntity.ok(ApiResponse.<OrderResponse>builder()
                .success(true)
                .message("Order details fetched successfully")
                .data(order)
                .build());
    }
    
    @PutMapping("/{orderNumber}/status")
    @Operation(summary = "Update order status", description = "Seller: PENDING‚ÜíCONFIRMED‚ÜíSHIPPED‚ÜíDELIVERED")
    public ResponseEntity<ApiResponse<OrderResponse>> updateStatus(
            @PathVariable String orderNumber,
            @RequestParam OrderStatus status,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "SELLER");
        log.info("Seller {} updating order {} to {}", sellerId, orderNumber, status);
        OrderResponse updated = orderService.updateStatus(orderNumber, sellerId, status)
                .map(this::mapToOrderResponse)
                .orElseThrow(() -> new BadRequestException("Order not found or update failed: " + orderNumber));
        return ResponseEntity.ok(ApiResponse.<OrderResponse>builder()
                .success(true)
                .message("Order status updated successfully")
                .data(updated)
                .build());
    }
    
    @PostMapping("/{orderNumber}/confirm")
    @Operation(summary = "Buyer confirms PENDING order", description = "Pay on Delivery final step")
    public ResponseEntity<ApiResponse<OrderResponse>> confirmOrder(
            @PathVariable String orderNumber,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        
        OrderResponse confirmed = orderService.confirmOrder(orderNumber, userId)
                .map(this::mapToOrderResponse)
                .orElseThrow(() -> new BadRequestException("Order not found or cannot confirm"));
        
        return ResponseEntity.ok(ApiResponse.<OrderResponse>builder()
                .success(true)
                .message("Order confirmed successfully!")
                .data(confirmed)
                .build());
    }
    
    
    
    @PostMapping("/{orderNumber}/cancel")
    @Operation(summary = "Cancel PENDING order")
    public ResponseEntity<ApiResponse<Void>> cancelOrder(
            @PathVariable String orderNumber,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        orderService.cancelOrder(orderNumber, userId);
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("Order cancelled successfully")
                .build());
    }
    
    @PostMapping("/{orderNumber}/redo")
    @Operation(summary = "Redo CANCELLED order")
    public ResponseEntity<ApiResponse<OrderResponse>> redoOrder(
            @PathVariable String orderNumber,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        OrderResponse newOrder = orderService.redoOrder(orderNumber, userId)
                .map(this::mapToOrderResponse)
                .orElseThrow(() -> new BadRequestException("Order not found: " + orderNumber));
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.<OrderResponse>builder()
                        .success(true)
                        .message("Order recreated successfully")
                        .data(newOrder)
                        .build());
    }
    
    @GetMapping("/buyer/search")
    @Operation(summary = "Search buyer orders")
    public ResponseEntity<ApiResponse<Page<OrderResponse>>> searchMyOrders(
            @Valid @ModelAttribute OrderSearchRequest req,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        Page<OrderResponse> orders = orderService.searchBuyerOrders(userId, req)
                .map(this::mapToOrderResponse);
        return ResponseEntity.ok(ApiResponse.<Page<OrderResponse>>builder()
                .success(true)
                .message("Buyer orders search completed")
                .data(orders)
                .build());
    }
    
    @GetMapping("/seller")
    @Operation(summary = "Get seller orders", description = "Paginated dashboard")
    public ResponseEntity<ApiResponse<Page<OrderResponse>>> getSellerOrders(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "SELLER");
        Pageable pageable = PageRequest.of(page, size);
        Page<OrderResponse> orders = orderService.getSellerOrders(sellerId, pageable)
                .map(this::mapToOrderResponse);
        return ResponseEntity.ok(ApiResponse.<Page<OrderResponse>>builder()
                .success(true)
                .message("Seller orders fetched successfully")
                .data(orders)
                .build());
    }
    
    private void validateRole(String role, String requiredRole) {
        if (!requiredRole.equals(role)) {
            throw new BadRequestException("Required role: " + requiredRole + ", got: " + role);
        }
    }
    
    private OrderResponse mapToOrderResponse(Order order) {
        List<OrderItemResponse> items = order.getItems().stream()
                .map(item -> OrderItemResponse.builder()
                        .productName(item.getProductName())
                        .sellerId(item.getSellerId())
                        .price(item.getPrice())
                        .quantity(item.getQuantity())
                        .build())
                .collect(Collectors.toList());
        
        return OrderResponse.builder()
                .orderNumber(order.getOrderNumber())
                .status(order.getStatus())
                .total(order.getTotal())
                .subtotal(order.getSubtotal())
                .tax(order.getTax())
                .createdAt(order.getCreatedAt())
                .shippingAddress(order.getShippingAddress())
                .items(items)
                .build();
    }
}
```

#### Services
##### OrderServiceApplication.java
```java
package com.buyone.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableFeignClients
@EnableDiscoveryClient
public class OrderServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(OrderServiceApplication.class, args);
	}

}
```

##### CartService.java
```java
package com.buyone.orderservice.service;

import com.buyone.orderservice.model.cart.Cart;
import com.buyone.orderservice.model.cart.CartItem;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Min;
import java.util.Optional;

public interface CartService {
    Cart addItem(@NotBlank String userId, CartItem item);
    Optional<Cart> getCart(String userId);
    Cart updateQuantity(@NotBlank String userId, @NotBlank String productId, @Min(1) int quantity);
    Cart removeItem(@NotBlank String userId, String productId);
    Cart clearCart(@NotBlank String userId);
    void saveCart(Cart cart);
    
}```

##### OrderService.java
```java
package com.buyone.orderservice.service;

import com.buyone.orderservice.dto.request.order.OrderSearchRequest;
import com.buyone.orderservice.model.Address;
import com.buyone.orderservice.model.order.Order;
import com.buyone.orderservice.model.order.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;

public interface OrderService {
    Order createOrderFromCart(String userId, Address shippingAddress);
    
    List<Order> getBuyerOrders(String userId);
    
    Optional<Order> getOrder(String orderNumber);
    
    Optional<Order> updateStatus(String orderNumber, String sellerId, OrderStatus status);
    
    Page<Order> searchBuyerOrders(String userId, OrderSearchRequest req);
    
    Page<Order> getSellerOrders(String sellerId, Pageable pageable);
    
    Optional<Order> confirmOrder(String orderNumber, String userId);
    
    void cancelOrder(String orderNumber, String userId);  // Only PENDING ‚Üí CANCELLED
    
    Optional<Order> redoOrder(String orderNumber, String userId);   // CANCELLED ‚Üí new cart ‚Üí new order
}
```

##### ProfileAnalyticsService.java
```java
package com.buyone.orderservice.service;

import com.buyone.orderservice.dto.response.analytics.ClientAnalyticsResponse;
import com.buyone.orderservice.dto.response.analytics.SellerAnalyticsResponse;

public interface ProfileAnalyticsService {
    ClientAnalyticsResponse getClientAnalytics(String userId);
    SellerAnalyticsResponse getSellerAnalytics(String sellerId);
}
```

##### CartServiceImpl.java
```java
package com.buyone.orderservice.service.impl;

import com.buyone.orderservice.client.ProductClient;
import com.buyone.orderservice.exception.BadRequestException;
import com.buyone.orderservice.model.Product;
import com.buyone.orderservice.model.cart.Cart;
import com.buyone.orderservice.model.cart.CartItem;
import com.buyone.orderservice.dto.response.ProductResponse;
import com.buyone.orderservice.dto.response.ApiResponse;
import com.buyone.orderservice.repository.CartRepository;
import com.buyone.orderservice.service.CartService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;
import org.springframework.beans.factory.annotation.Value;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
@Validated  // For method-level validation
public class CartServiceImpl implements CartService {
    
    private final CartRepository cartRepository;
    private final ProductClient productClient;  //  Fixed: no @Autowired
    
    @Value("${app.cart.tax-rate:0.1}")  //  Configurable
    private double taxRate;
    
    @Override
    @Transactional  // Consistency guarantee
    public Cart addItem(String userId, CartItem item) {
        validateCartItem(item);
        Cart cart = getOrCreateCart(userId);
        
        // Merge if exists (multi-seller support)
        Optional<CartItem> existing = cart.getItems().stream()
                .filter(ci -> ci.getProductId().equals(item.getProductId())
                        && ci.getSellerId().equals(item.getSellerId()))
                .findFirst();
        
        if (existing.isPresent()) {
            existing.get().setQuantity(existing.get().getQuantity() + item.getQuantity());
        } else {
            // Production integration - Full ApiResponse handling
            ApiResponse<ProductResponse> response = productClient.getById(item.getProductId());
            
            if (!response.isSuccess() || response.getData() == null) {
                log.warn("Product not found: {}", item.getProductId());
                throw new BadRequestException("Product not found: " + item.getProductId());
            }
            
            ProductResponse product = response.getData();
            
            // Debug logs (keep for now)
            log.info("Product: {} quantity={}, request qty={}",
                    product.getId(),
                    product.getQuantity(),
                    item.getQuantity());
            
            int availableStock = Optional.ofNullable(product.getQuantity()).orElse(0);
            log.info("Available: {}, requested: {}", availableStock, item.getQuantity());
            
            if (availableStock < item.getQuantity()) {
                throw new BadRequestException("Insufficient stock: " + item.getQuantity() +
                        " requested, " + availableStock + " available");
            }
            
            // Populate cart item snapshot
            item.setProductName(product.getName());
            item.setPrice(product.getPrice());
            item.setImageUrl(product.getImages() != null && !product.getImages().isEmpty()
                    ? product.getImages().get(0) : null);
            
            cart.getItems().add(item);
        }
        return recalculateTotals(cart);
    }
    
    @Override
    public Optional<Cart> getCart(String userId) {
        return cartRepository.findById(userId);
    }
    
    @Override
    @Transactional
    public Cart updateQuantity(String userId, String productId,
                               int quantity) {
        Cart cart = getOrCreateCart(userId);
        boolean updated = cart.getItems().stream()
                .filter(ci -> ci.getProductId().equals(productId))
                .findFirst()
                .map(ci -> {
                    ci.setQuantity(quantity);
                    return true;
                }).orElse(false);
        
        if (!updated) {
            throw new BadRequestException("Product not found in cart: " + productId);
        }
        
        cart.getItems().removeIf(ci -> ci.getQuantity() <= 0);
        return recalculateTotals(cart);
    }
    
    @Override
    @Transactional
    public Cart removeItem(String userId, String productId) {
        Cart cart = getOrCreateCart(userId);
        boolean removed = cart.getItems().removeIf(ci -> ci.getProductId().equals(productId));
        if (!removed) {
            log.warn("Item not found in cart: user={}, product={}", userId, productId);
        }
        return recalculateTotals(cart);
    }
    
    @Override
    @Transactional
    public Cart clearCart(String userId) {
        return cartRepository.save(Cart.builder()
                .id(userId)
                .userId(userId)
                .items(new ArrayList<>())
                .subtotal(BigDecimal.ZERO)
                .tax(BigDecimal.ZERO)
                .total(BigDecimal.ZERO)
                .updatedAt(LocalDateTime.now())
                .build());
    }
    
    private Cart getOrCreateCart(String userId) {
        return cartRepository.findById(userId)
                .orElse(Cart.builder()
                        .id(userId)
                        .userId(userId)
                        .items(new ArrayList<>())
                        .build());
    }
    
    private Cart recalculateTotals(Cart cart) {
        BigDecimal subtotal = cart.getItems().stream()
                .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal tax = subtotal.multiply(BigDecimal.valueOf(taxRate))
                .setScale(2, RoundingMode.HALF_UP);
        BigDecimal total = subtotal.add(tax);
        
        cart.setSubtotal(subtotal);
        cart.setTax(tax);
        cart.setTotal(total);
        cart.setUpdatedAt(LocalDateTime.now());
        
        return cartRepository.save(cart);
    }
    
    private void validateCartItem(CartItem item) {
        if (item.getQuantity() <= 0) {
            throw new BadRequestException("Quantity must be positive");
        }
        if (item.getProductId() == null || item.getProductId().trim().isEmpty()) {
            throw new BadRequestException("Product ID is required");
        }
        if (item.getSellerId() == null || item.getSellerId().trim().isEmpty()) {
            throw new BadRequestException("Seller ID is required");
        }
    }
    @Override
    @Transactional
    public void saveCart(Cart cart) {
        cartRepository.save(cart);
    }
    
}
```

##### OrderServiceImpl.java
```java
package com.buyone.orderservice.service.impl;

import com.buyone.orderservice.client.ProductClient;
import com.buyone.orderservice.dto.request.order.OrderSearchRequest;
import com.buyone.orderservice.dto.request.ReserveStockRequest;
import com.buyone.orderservice.dto.request.ReleaseStockRequest;
import com.buyone.orderservice.exception.BadRequestException;
import com.buyone.orderservice.exception.ResourceNotFoundException;
import com.buyone.orderservice.model.*;
import com.buyone.orderservice.model.cart.Cart;
import com.buyone.orderservice.model.cart.CartItem;
import com.buyone.orderservice.model.order.Order;
import com.buyone.orderservice.model.order.OrderItem;
import com.buyone.orderservice.model.order.OrderStatus;
import com.buyone.orderservice.model.order.PaymentMethod;
import static com.buyone.orderservice.model.order.OrderStatus.*;
import static com.buyone.orderservice.model.order.PaymentMethod.PAY_ON_DELIVERY;
import com.buyone.orderservice.repository.OrderRepository;
import com.buyone.orderservice.service.CartService;
import com.buyone.orderservice.service.OrderService;
import com.buyone.orderservice.dto.response.ProductResponse;
import com.buyone.orderservice.dto.response.ApiResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * OrderService implementation with re-fetch snapshot strategy for production accuracy.
 * Creates immutable order records with fresh product data at checkout time.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class OrderServiceImpl implements OrderService {
    
    private final OrderRepository orderRepository;
    private final CartService cartService;
    private final ProductClient productClient;  // Re-fetches live product data
    
    /**
     * Creates order from cart with FRESH product snapshots (price/name/seller).
     * Validates cart ‚Üí re-fetches products ‚Üí calculates totals ‚Üí saves ‚Üí clears cart.
     */
    @Override
    public Order createOrderFromCart(String userId, Address shippingAddress) {
        var cartItems = getValidatedCartItems(userId);
        
        // Re-fetch LIVE products ‚Üí Fresh, legally-accurate snapshots
        List<OrderItem> orderItems = cartItems.stream()
                .map(this::fetchFreshProductSnapshot)
                .toList();
        
        // Precise money calculations
        BigDecimal subtotal = calculateSubtotal(orderItems);
        BigDecimal tax = calculateTax(subtotal);
        
        // Build order
        String orderNumber = generateOrderNumber();
        Order order = Order.builder()
                .userId(userId)
                .orderNumber(orderNumber)
                .items(orderItems)
                .status(OrderStatus.PENDING)
                .paymentMethod(PaymentMethod.PAY_ON_DELIVERY)
                .shippingAddress(shippingAddress)
                .subtotal(subtotal)
                .tax(tax)
                .total(subtotal.add(tax))
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();
        
        Order saved = orderRepository.save(order);
        
        // Post-checkout actions
        reserveInventory(saved.getItems(), saved.getOrderNumber());
        
//        // 2. NEW: auto-confirm Pay on Delivery
//        if (saved.getPaymentMethod() == PaymentMethod.PAY_ON_DELIVERY) {
//            saved.setStatus(OrderStatus.CONFIRMED);
//            saved.setUpdatedAt(LocalDateTime.now());
//            saved = orderRepository.save(saved);  // Save CONFIRMED
            
            // Commit: delete reservations, qty stays deducted ‚úÖ
//            productClient.commitStock(saved.getOrderNumber());
//            log.info("Auto-confirmed Pay on Delivery order {}", saved.getOrderNumber());
//        }
        
        cartService.clearCart(userId);
        
        log.info("Order {} created for {} (subtotal: {})", orderNumber, userId, subtotal);
        return saved;
    }
    
    @Override
    public Optional<Order> confirmOrder(String orderNumber, String userId) {
        return getOrder(orderNumber)
                .filter(order -> userId.equals(order.getUserId()))      // Buyer owns order
                .filter(order -> order.getStatus() == OrderStatus.PENDING)  // Only PENDING
                .map(order -> {
                    OrderStatus oldStatus = order.getStatus();
                    order.setStatus(OrderStatus.CONFIRMED);
                    order.setUpdatedAt(LocalDateTime.now());
                    Order saved = orderRepository.save(order);
                    
                    // Commit stock (same as seller updateStatus)
                    productClient.commitStock(orderNumber);
                    log.info("Buyer {} confirmed order {}", userId, orderNumber);
                    
                    return saved;
                });
    }

    
    
    /**
     * Gets cart items with validation - quantities only (don't trust stale cart data).
     */
    private List<CartItem> getValidatedCartItems(String userId) {
        var cartOpt = cartService.getCart(userId);
        var cartItems = cartOpt.map(Cart::getItems)
                .orElseThrow(() -> new ResourceNotFoundException("Cart not found: " + userId));
        if (cartItems.isEmpty()) throw new IllegalStateException("Empty cart");
        return cartItems;
    }
    
    /**
     * Fetches LIVE product data ‚Üí Creates immutable snapshot for order.
     * Guarantees accuracy even if seller changed price/name since cart add.
     */
    private OrderItem fetchFreshProductSnapshot(CartItem cartItem) {
        ApiResponse<ProductResponse> response = productClient.getById(cartItem.getProductId());
        
        if (!response.isSuccess() || response.getData() == null) {
            log.warn("Product not found for order snapshot: {}", cartItem.getProductId());
            throw new ResourceNotFoundException("Product not found: " + cartItem.getProductId());
        }
        
        ProductResponse product = response.getData();
        
        return OrderItem.builder()
                .productId(product.getId())
                .productName(product.getName())
                .sellerId(product.getUserId())  // Maps userId ‚Üí sellerId
                .price(product.getPrice())
                .quantity(cartItem.getQuantity())
                .imageUrl(safeFirstImage(product.getImages()))
                .build();
    }

    
    /**
     * Safely extracts first image URL - null-safe.
     */
    private String safeFirstImage(List<String> images) {
        return images != null && !images.isEmpty() ? images.get(0) : null;
    }
    
    /**
     * Generates unique order number: ORD-ABC12345
     */
    private String generateOrderNumber() {
        return "ORD-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }
    
    /**
     * Calculates subtotal: Œ£(price √ó quantity) exactly.
     */
    private BigDecimal calculateSubtotal(List<OrderItem> items) {
        return items.stream()
                .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    /**
     * 10% tax, rounded to 2 decimals (business rule).
     */
    private BigDecimal calculateTax(BigDecimal subtotal) {
        return subtotal.multiply(BigDecimal.valueOf(0.1)).setScale(2, RoundingMode.HALF_UP);
    }
    
    /**
     * Queues inventory reservation (TODO: @Async + RabbitMQ).
     */
    private void reserveInventory(List<OrderItem> items, String orderNumber) {
        for (OrderItem item : items) {
            ReserveStockRequest req = new ReserveStockRequest(
                    item.getProductId(),
                    item.getQuantity(),
                    orderNumber
            );
            
            ApiResponse<Void> response = productClient.reserveStock(req);
            if (!response.isSuccess()) {
                throw new BadRequestException(
                        "Failed to reserve stock for product: " + item.getProductId() +
                                ". Error: " + response.getMessage());
            }
            log.info("Reserved {} units of {} for order {}",
                    item.getQuantity(), item.getProductId(), orderNumber);
        }
    }
    
    // ========== EXISTING METHODS (PERFECT - MINOR ENUM FIXES) ==========
    
    @Override
    public List<Order> getBuyerOrders(String userId) {
        return orderRepository.findByUserId(userId);
    }
    
    @Override
    public Optional<Order> getOrder(String orderNumber) {
        return orderRepository.findByOrderNumber(orderNumber);
    }
    
    /**
     * Seller/admin updates status (CONFIRMED‚ÜíSHIPPED‚ÜíDELIVERED).
     */
    @Override
    public Optional<Order> updateStatus(String orderNumber, String sellerId, OrderStatus status) {
        Order order = getOrder(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found: " + orderNumber));
        
        // CRITICAL CHECK
        // Seller owns all items
        boolean ownsAllItems = order.getItems().stream()
                .allMatch(item -> sellerId.equals(item.getSellerId()));
        if (!ownsAllItems) {
            throw new BadRequestException("Seller not authorized for this order");
        }
        
        OrderStatus oldStatus = order.getStatus();
        
        order.setStatus(status);
        order.setUpdatedAt(LocalDateTime.now());
        Order saved = orderRepository.save(order);
        
        // NEW: commit stock once when leaving PENDING
        if (oldStatus == OrderStatus.PENDING && status == OrderStatus.CONFIRMED) {
            // We only need orderNumber to commit all reservations
            productClient.commitStock(orderNumber);
            log.info("Committed stock reservations for order {}", orderNumber);
        }
        
        return Optional.of(saved);
    }
    
    /**
     * Buyer cancels PENDING order ‚Üí CANCELLED.
     */
    @Override
    public void cancelOrder(String orderNumber, String userId) {
        Order order = getOrder(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found: " + orderNumber));
        // ownership check
        if (!userId.equals(order.getUserId())) {
            throw new BadRequestException("Not your order");
        }
        
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new IllegalStateException("Only PENDING orders can be cancelled");
        }
        
        order.setStatus(OrderStatus.CANCELLED);
        order.setUpdatedAt(LocalDateTime.now());
        orderRepository.save(order);
        order.getItems().forEach(item -> {
            ReleaseStockRequest req = new ReleaseStockRequest(
                    item.getProductId(),
                    item.getQuantity()
            );
            productClient.releaseStock(req);
            log.info("Released {} units of {} for cancelled order {}",
                    item.getQuantity(), item.getProductId(), orderNumber);
        });
    }
    
    /**
     * Buyer redoes CANCELLED order ‚Üí clones to new cart ‚Üí new order.
     */
    @Override
    public Optional<Order> redoOrder(String orderNumber, String userId) {
        return getOrder(orderNumber)  // Optional chain
                .filter(order -> userId.equals(order.getUserId()))  // Ownership
                .filter(order -> order.getStatus() == OrderStatus.CANCELLED)
                .map(oldOrder -> {
                    List<CartItem> newItems = oldOrder.getItems().stream()
                            .map(this::orderItemToCartItem)
                            .collect(Collectors.toList());
                    Cart newCart = Cart.builder()
                            .userId(userId)
                            .items(newItems)
                            .build();
                    cartService.saveCart(newCart);
                    return createOrderFromCart(userId, oldOrder.getShippingAddress());  // Reuse original
                });
    }
    
    @Override
    public Page<Order> searchBuyerOrders(String userId, OrderSearchRequest req) {
        OrderStatus status = req.getStatus() != null
                ? OrderStatus.valueOf(req.getStatus().toUpperCase())
                : null;
        Pageable pageable = PageRequest.of(req.getPage(), req.getSize());
        return orderRepository.findBuyerOrdersSearch(userId, req.getKeyword(), status, pageable);
    }
    
    @Override
    public Page<Order> getSellerOrders(String sellerId, Pageable pageable) {
        return orderRepository.findSellerOrders(sellerId, pageable);
    }
    
    /**
     * Converts OrderItem ‚Üí CartItem for redo (double back-convert).
     */
    private CartItem orderItemToCartItem(OrderItem item) {
        return CartItem.builder()
                .productId(item.getProductId())
                .productName(item.getProductName())
                .sellerId(item.getSellerId())
                .price(item.getPrice())
                .quantity(item.getQuantity())
                .imageUrl(item.getImageUrl())
                .build();
    }
}
```

##### ProfileAnalyticsServiceImpl.java
```java
package com.buyone.orderservice.service.impl;

import com.buyone.orderservice.dto.response.analytics.*;
import com.buyone.orderservice.repository.OrderRepository;
import com.buyone.orderservice.service.ProfileAnalyticsService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProfileAnalyticsServiceImpl implements ProfileAnalyticsService {
    
    private final OrderRepository orderRepository;
    
    @Override
    public ClientAnalyticsResponse getClientAnalytics(String userId) {
        // ‚úÖ Use your new repo methods (no MongoTemplate needed!)
        List<ClientTotalSpent> totalSpentList = orderRepository.getClientTotalSpent(userId);
        List<ClientMostBought> mostBought = orderRepository.getClientMostBought(userId);
        List<ClientTopCategory> topCategories = orderRepository.getClientTopCategories(userId);
        
        BigDecimal totalSpent = totalSpentList.isEmpty()
                ? BigDecimal.ZERO
                : totalSpentList.get(0).totalSpent();
        
        log.info("Client {} analytics: ${} spent, {} top products",
                userId, totalSpent, mostBought.size());
        
        return new ClientAnalyticsResponse(totalSpent, mostBought, topCategories);
    }
    
    @Override
    public SellerAnalyticsResponse getSellerAnalytics(String sellerId) {
        List<SellerTotalRevenue> revenueList = orderRepository.getSellerTotalRevenue(sellerId);
        List<SellerBestProduct> bestProducts = orderRepository.getSellerBestProducts(sellerId);
        List<SellerTotalUnits> unitsList = orderRepository.getSellerTotalUnits(sellerId);
        
        BigDecimal totalRevenue = revenueList.isEmpty()
                ? BigDecimal.ZERO
                : revenueList.get(0).totalRevenue();
        
        Integer totalUnits = unitsList.isEmpty()
                ? 0
                : unitsList.get(0).totalUnits();
        
        log.info("Seller {} analytics: ${} revenue, {} units, {} top products",
                sellerId, totalRevenue, totalUnits, bestProducts.size());
        
        return new SellerAnalyticsResponse(totalRevenue, bestProducts, totalUnits);
    }
}
```

#### Repositories
##### CartRepository.java
```java
package com.buyone.orderservice.repository;

import com.buyone.orderservice.model.cart.Cart;
import org.springframework.data.mongodb.repository.MongoRepository;
import java.util.Optional;

public interface CartRepository extends MongoRepository<Cart, String> {
    Optional<Cart> findById(String userId);
    
    
    // MongoRepository ALREADY has these:
    // Cart save(Cart cart);           ‚Üê inherited
    // void deleteById(String userId); ‚Üê inherited
    
    // CUSTOM queries we'll need:
    // void deleteItem(String userId, String productId);  (later)
}
```

##### OrderRepository.java
```java
package com.buyone.orderservice.repository;

import com.buyone.orderservice.dto.response.analytics.*;
import com.buyone.orderservice.model.order.Order;
import com.buyone.orderservice.model.order.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.Aggregation;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;

import com.buyone.orderservice.dto.response.analytics.ClientTotalSpent;
import com.buyone.orderservice.dto.response.analytics.ClientMostBought;
import com.buyone.orderservice.dto.response.analytics.ClientTopCategory;
import com.buyone.orderservice.dto.response.analytics.SellerTotalRevenue;
import com.buyone.orderservice.dto.response.analytics.SellerBestProduct;
import com.buyone.orderservice.dto.response.analytics.SellerTotalUnits;


import java.util.List;
import java.util.Optional;

/**
 * OrderRepository with analytics aggregations for user/seller dashboards.
 * Uses MongoDB aggregation pipelines for efficient, indexed analytics queries.
 * Indexes recommended: {userId:1, status:1}, {status:1, "items.sellerId":1}
 */
public interface OrderRepository extends MongoRepository<Order, String> {
    
    List<Order> findByUserId(String userId);           // Buyer orders
    List<Order> findByUserIdAndStatus(String userId, OrderStatus status);
    Optional<Order> findByOrderNumber(String orderNumber);
    
    @Query(value = "{ 'userId': ?0, $or: [ " +
            "{ 'orderNumber': { $regex: ?1, $options: 'i' } }, " +
            "{ 'items.productName': { $regex: ?1, $options: 'i' } }, " +
            "{ 'status': ?2 } ] }",
            sort = "{ 'createdAt': -1 }")
    Page<Order> findBuyerOrdersSearch(String userId, String keyword, OrderStatus status, Pageable pageable);
    
    @Query("{ 'items.sellerId': ?0 }")
    Page<Order> findSellerOrders(String sellerId, Pageable pageable);
    // === CLIENT ANALYTICS ===
    @Aggregation(value = {
            "{ $match: { userId: ?0, status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $group: { _id: '$userId', totalSpent: { $sum: '$total' } } }"
    })
    List<ClientTotalSpent> getClientTotalSpent(String userId);
    
    @Aggregation(value = {
            "{ $match: { userId: ?0, status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $group: { _id: { productId: '$items.productId', name: '$items.productName' }, totalQty: { $sum: '$items.quantity' } } }",
            "{ $sort: { totalQty: -1 } }",
            "{ $limit: 5 }"
    })
    List<ClientMostBought> getClientMostBought(String userId);
    
    @Aggregation(value = {
            "{ $match: { userId: ?0, status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $group: { _id: '$items.category', totalSpent: { $sum: { $multiply: [ '$items.price', '$items.quantity' ] } } } }",
            "{ $sort: { totalSpent: -1 } }",
            "{ $limit: 5 }"
    })
    List<ClientTopCategory> getClientTopCategories(String userId);
    
    // === SELLER ANALYTICS ===
    @Aggregation(value = {
            "{ $match: { status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $match: { 'items.sellerId': ?0 } }",
            "{ $group: { _id: null, totalRevenue: { $sum: { $multiply: [ '$items.price', '$items.quantity' ] } } } }"
    })
    List<SellerTotalRevenue> getSellerTotalRevenue(String sellerId);
    
    @Aggregation(value = {
            "{ $match: { status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $match: { 'items.sellerId': ?0 } }",
            "{ $group: { _id: { productId: '$items.productId', name: '$items.productName' }, revenue: { $sum: { $multiply: [ '$items.price', '$items.quantity' ] } }, unitsSold: { $sum: '$items.quantity' } } }",
            "{ $sort: { revenue: -1 } }",
            "{ $limit: 5 }"
    })
    List<SellerBestProduct> getSellerBestProducts(String sellerId);
    
    @Aggregation(value = {
            "{ $match: { status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $match: { 'items.sellerId': ?0 } }",
            "{ $group: { _id: null, totalUnits: { $sum: '$items.quantity' } } }"
    })
    List<SellerTotalUnits> getSellerTotalUnits(String sellerId);
    
}
```

#### Models/DTOs (Top 10)
##### ReleaseStockRequest.java
```java
package com.buyone.orderservice.dto.request;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReleaseStockRequest {
    @NotBlank(message = "Product ID is required")
    private String productId;
    
    @Min(value = 1, message = "Quantity must be at least 1")
    private int quantity;
}
```

##### ReserveStockRequest.java
```java
package com.buyone.orderservice.dto.request;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReserveStockRequest {
    @NotBlank(message = "Product ID is required")
    private String productId;
    
    @Min(value = 1, message = "Quantity must be at least 1")
    private int quantity;
    
    @NotBlank(message = "Order number is required")
    private String orderNumber;
}
```

##### AddCartItemRequest.java
```java
// AddCartItemRequest.java
package com.buyone.orderservice.dto.request.cart;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.Builder;

@Data @Builder
public class AddCartItemRequest {
    @NotBlank String productId;
    @NotBlank String sellerId;
    @Min(1) int quantity;
}
```

##### UpdateCartQuantityRequest.java
```java
// UpdateCartQuantityRequest.java
package com.buyone.orderservice.dto.request.cart;

import jakarta.validation.constraints.Min;
import lombok.Data;

@Data
public class UpdateCartQuantityRequest {
    @Min(1) int quantity;
}
```

##### CreateOrderRequest.java
```java
package com.buyone.orderservice.dto.request.order;

import com.buyone.orderservice.model.Address;
import jakarta.validation.Valid;
import lombok.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateOrderRequest {
    @Valid
    private Address shippingAddress;
}
```

##### OrderSearchRequest.java
```java
package com.buyone.orderservice.dto.request.order;

import jakarta.validation.constraints.Min;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class OrderSearchRequest {
    private String keyword;  // Product name/status search
    
    private String status;   // Optional filter: PENDING, etc.
    
    @Min(0)
    @Builder.Default
    private Integer page = 0;
    
    @Min(1)
    @Builder.Default
    private Integer size = 10;
}
```

##### ApiResponse.java
```java
package com.buyone.orderservice.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
}
```

##### ErrorResponse.java
```java
package com.buyone.orderservice.dto.response;

public record ErrorResponse(String code, String message, Object details) {}
```

##### ProductResponse.java
```java
package com.buyone.orderservice.dto.response;

import lombok.Data;
import java.math.BigDecimal;
import java.util.List;

@Data
public class ProductResponse {
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer quantity;
    private String userId;      // Maps to sellerId
    private String categoryId;
    private List<String> images;
}
```

##### ClientAnalyticsResponse.java
```java
package com.buyone.orderservice.dto.response.analytics;

import java.math.BigDecimal;
import java.util.List;

public record ClientAnalyticsResponse(
        BigDecimal totalSpent,
        List<ClientMostBought> mostBoughtProducts,
        List<ClientTopCategory> topCategories
) {}
```

---

### üü¢ product-service

#### pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.1.8</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.buyone</groupId>
	<artifactId>product-service</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>Product Service</name>
	<description>Managing product catalog operations for buy-one</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2022.0.5</spring-cloud.version>
	</properties>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka</artifactId>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
			<version>1.18.30</version>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-ui</artifactId>
            <version>1.7.0</version>
        </dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka-test</artifactId>
			<scope>test</scope>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
        </dependency>
	</dependencies>


	<build>
		<plugins>
            <!-- Maven Compiler Plugin for Lombok support -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
				<version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
							<version>1.18.34</version>
                        </path>
                    </annotationProcessorPaths>
                    <release>${java.version}</release>
                </configuration>
            </plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>
```

#### Controllers
##### CategoryController.java
```java
package com.buyone.productservice.controller;

import com.buyone.productservice.response.CategoryResponse;
import com.buyone.productservice.request.UpdateCategoryRequest;
import com.buyone.productservice.service.CategoryService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/categories")
@RequiredArgsConstructor
public class CategoryController {
    
    private final CategoryService categoryService;
    
    @GetMapping
    public ResponseEntity<List<CategoryResponse>> getAll() {
        return ResponseEntity.ok(categoryService.getAllCategories());
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<CategoryResponse> getOne(@PathVariable String id) {
        return ResponseEntity.ok(categoryService.getCategoryById(id));
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<CategoryResponse> updateCategory(
            @PathVariable String id,
            @Valid @RequestBody UpdateCategoryRequest request
    ) {
        CategoryResponse updated = categoryService.updateCategory(id, request);
        return ResponseEntity.ok(updated);
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCategory(@PathVariable String id) {
        categoryService.deleteCategory(id);
        return ResponseEntity.noContent().build();
    }
}
```

##### ProductController.java
```java
package com.buyone.productservice.controller;

import com.buyone.productservice.request.CreateProductRequest;
import com.buyone.productservice.request.UpdateProductRequest;
import com.buyone.productservice.request.ReserveStockRequest;
import com.buyone.productservice.request.ReleaseStockRequest;
import com.buyone.productservice.response.ProductResponse;
import com.buyone.productservice.response.ApiResponse;
import com.buyone.productservice.exception.ForbiddenException;
import com.buyone.productservice.service.ProductService;
import lombok.RequiredArgsConstructor;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import jakarta.validation.Valid;
import java.math.BigDecimal;
import java.util.List;

@RestController
@RequestMapping("/products")
@Validated
@RequiredArgsConstructor
public class ProductController {
    
    private final ProductService productService;
    
    // GET /products (public) or GET /products?sellerId=... (public)
    @GetMapping
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getProducts(
            @RequestParam(required = false) String sellerId) {

        List<ProductResponse> products;

        if (sellerId != null) {
            products = productService.getProductsBySeller(sellerId);
        } else {
            products = productService.getAllProducts();
        }

        return ResponseEntity.ok(okResponse("Products fetched successfully", products));
    }

    // GET /products/search (public - faceted search with pagination)
    @GetMapping("/search")
    public ResponseEntity<ApiResponse<Page<ProductResponse>>> searchProducts(
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) BigDecimal minPrice,
            @RequestParam(required = false) BigDecimal maxPrice,
            @RequestParam(required = false) String categoryId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        Pageable pageable = PageRequest.of(page, size);
        Page<ProductResponse> results = productService.searchProducts(
            keyword, minPrice, maxPrice, categoryId, pageable
        );
        
        return ResponseEntity.ok(
            ApiResponse.<Page<ProductResponse>>builder()
                .success(true)
                .message("Search results fetched successfully")
                .data(results)
                .build()
        );
    }
    
    
    // GET /products/{id} (public)
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductResponse>> getProductById(@PathVariable String id) {
        ProductResponse product = productService.getProductById(id);
        return ResponseEntity.ok(okResponse("Product fetched successfully", product));
    }
    
    // POST /products (seller only)
    @PostMapping
    public ResponseEntity<ApiResponse<ProductResponse>> createProduct(
            @Valid @RequestBody CreateProductRequest request,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role
    ) {
        if (!"SELLER".equals(role)) {
            throw new ForbiddenException("Only sellers can create products.");
        }
        
        ProductResponse product = productService.createProduct(request, sellerId);
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(okResponse("Product created successfully", product));
    }
    
    // PUT /products/{id} (seller only & must own)
    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductResponse>> updateProduct(
            @PathVariable String id,
            @Valid @RequestBody UpdateProductRequest request,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role
    ) {
        if (!"SELLER".equals(role)) {
            throw new ForbiddenException("Only sellers can update products.");
        }
        
        ProductResponse product = productService.updateProduct(id, request, sellerId);
        return ResponseEntity.ok(okResponse("Product updated successfully", product));
    }
    
    // DELETE /products/{id} (seller only & must own)
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteProduct(
            @PathVariable String id,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role
    ) {
        if (!"SELLER".equals(role)) {
            throw new ForbiddenException("Only sellers can delete products.");
        }
        
        productService.deleteProduct(id, sellerId);
        return ResponseEntity.ok(okResponse("Product deleted successfully", null));
    }
    
    @PostMapping("/stock/reserve")
    public ResponseEntity<ApiResponse<Void>> reserveStock(
            @Valid @RequestBody ReserveStockRequest request) {
        
        productService.reserveStock(
                request.getProductId(),
                request.getQuantity(),
                request.getOrderNumber()
        );
        
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("Stock reserved successfully")
                .build());
    }
    
    @PostMapping("/stock/release")
    public ResponseEntity<ApiResponse<Void>> releaseStock(
            @Valid @RequestBody ReleaseStockRequest request) {
        
        productService.releaseStock(
                request.getProductId(),
                request.getQuantity()
        );
        
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("Stock released successfully")
                .build());
    }
    
    @PostMapping("/stock/commit/{orderNumber}")
    public ResponseEntity<Void> commitStock(@PathVariable String orderNumber) {
        productService.commitReservations(orderNumber);  // We'll add this method next
        return ResponseEntity.ok().build();
    }
    
    
    
    // Helper to build ApiResponse consistently
    private <T> ApiResponse<T> okResponse(String message, T data) {
        return ApiResponse.<T>builder()
                .success(true)
                .message(message)
                .data(data)
                .build();
    }
}
```

#### Services
##### ProductServiceApplication.java
```java
package com.buyone.productservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class ProductServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ProductServiceApplication.class, args);
	}

}
```

##### CategoryService.java
```java
package com.buyone.productservice.service;

import com.buyone.productservice.request.UpdateCategoryRequest;
import com.buyone.productservice.response.CategoryResponse;

import java.util.List;

public interface CategoryService {
    List<CategoryResponse> getAllCategories();
    CategoryResponse getCategoryById(String id);
    CategoryResponse updateCategory(String id, UpdateCategoryRequest request);
    void deleteCategory(String id);
}
```

##### CategoryServiceImpl.java
```java
package com.buyone.productservice.service;

import com.buyone.productservice.exception.ResourceNotFoundException;
import com.buyone.productservice.model.Category;
import com.buyone.productservice.repository.CategoryRepository;
import com.buyone.productservice.request.UpdateCategoryRequest;
import com.buyone.productservice.response.CategoryResponse;
import com.buyone.productservice.service.CategoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class CategoryServiceImpl implements CategoryService {
    
    private final CategoryRepository categoryRepository;
    
    @Override
    public List<CategoryResponse> getAllCategories() {
        return categoryRepository.findAll()
                .stream()
                .map(this::toResponse)
                .toList();
    }
    
    @Override
    public CategoryResponse getCategoryById(String id) {
        var category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found: " + id));
        return toResponse(category);
    }
    
    @Override
    public void deleteCategory(String id) {
        if (!categoryRepository.existsById(id)) {
            throw new ResourceNotFoundException("Category not found: " + id);
        }
        categoryRepository.deleteById(id);
    }
    
    @Override
    public CategoryResponse updateCategory(String id, UpdateCategoryRequest request) {
        Category cat = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found: " + id));
        cat.setName(request.getName());
        cat.setIcon(request.getIcon());
        cat.setDescription(request.getDescription());
        Category saved = categoryRepository.save(cat);
        return toResponse(saved);
    }
    
    private CategoryResponse toResponse(Category c) {
        return new CategoryResponse(
                c.getId(),
                c.getSlug(),
                c.getName(),
                c.getIcon(),
                c.getDescription()
        );
    }
}
```

##### ProductService.java
```java
package com.buyone.productservice.service;

import com.buyone.productservice.request.CreateProductRequest;
import com.buyone.productservice.request.UpdateProductRequest;
import com.buyone.productservice.response.ProductResponse;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;
import java.util.List;

public interface ProductService {
    ProductResponse createProduct(CreateProductRequest request, String sellerId);
    ProductResponse getProductById(String id);
    List<ProductResponse> getAllProducts();
    ProductResponse updateProduct(String id, UpdateProductRequest request, String sellerId);
    void deleteProduct(String id, String sellerId);
    List<ProductResponse> getProductsBySeller(String sellerId); // for seller dashboard
    
    Page<ProductResponse> searchProducts(
        String keyword, 
        BigDecimal minPrice, 
        BigDecimal maxPrice, 
        String categoryId, 
        Pageable pageable
    );
    
    void reserveStock(String productId, int quantity, String orderNumber);
    void releaseStock(String productId, int quantity);
    void commitReservations(String orderNumber);
    
}


// Methods should use DTOs for incoming and outgoing data (except for internal lookups).```

##### ProductServiceImpl.java
```java
package com.buyone.productservice.service;

import com.buyone.productservice.model.Product;
import com.buyone.productservice.model.Reservation;
import com.buyone.productservice.repository.ProductRepository;
import com.buyone.productservice.repository.ReservationRepository;
import com.buyone.productservice.request.CreateProductRequest;
import com.buyone.productservice.request.UpdateProductRequest;
import com.buyone.productservice.response.ProductResponse;
import com.buyone.productservice.exception.ProductNotFoundException;
import com.buyone.productservice.exception.BadRequestException;
import com.buyone.productservice.exception.ConflictException;
import com.buyone.productservice.exception.ForbiddenException;
import com.buyone.productservice.event.ProductCreatedEvent;
import com.buyone.productservice.event.ProductUpdatedEvent;
import com.buyone.productservice.event.ProductDeletedEvent;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.kafka.core.KafkaTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import lombok.*;

import java.util.List;
import java.util.stream.Collectors;
import java.time.LocalDateTime;

@Service
public class ProductServiceImpl implements ProductService {
    
    private final ProductRepository productRepository;
    private final ReservationRepository reservationRepository;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    private static final Logger log = LoggerFactory.getLogger(ProductServiceImpl.class);
    
    
    @Value("${app.kafka.topic.product-created}")
    private String productCreatedTopic;
    @Value("${app.kafka.topic.product-updated}")
    private String productUpdatedTopic;
    @Value("${app.kafka.topic.product-deleted}")
    private String productDeletedTopic;
    
    public ProductServiceImpl(ProductRepository productRepository,
                              ReservationRepository reservationRepository,
                              KafkaTemplate<String, Object> kafkaTemplate) {
        this.productRepository = productRepository;
        this.reservationRepository = reservationRepository;
        this.kafkaTemplate = kafkaTemplate;
    }
    
    // Create Product (seller only, enforce at controller)
    @Override
    public ProductResponse createProduct(CreateProductRequest request, String sellerId) {
        
        // Example conflict check (duplicate product name for seller)
        if (productRepository.findByUserId(sellerId).stream()
                .anyMatch(p -> p.getName().equalsIgnoreCase(request.getName()))) {
            throw new ConflictException("Product name already exists for seller.");
        }
        
        Product product = Product.builder()
                .name(request.getName())
                .description(request.getDescription())
                .price(request.getPrice())
                .quantity(request.getQuantity())
                .userId(sellerId)
                .categoryId(request.getCategoryId())
                .images(request.getImages())
                .build();
        
        Product savedProduct = productRepository.save(product);
//        ProductCreatedEvent event = ProductCreatedEvent.builder()
//                .productId(savedProduct.getId())
//                .sellerId(sellerId)
//                .name(savedProduct.getName())
//                .price(savedProduct.getPrice())
//                .build();
        // Publish event
        // kafkaTemplate.send(productCreatedTopic, event)
        //         .whenComplete((result, ex) -> {
        //             if (ex != null) {
        //                 log.error("Failed to publish event", ex);
        //             } else {
        //                 log.info("Event published: " + event);
        //             }
        //         });
        return toProductResponse(savedProduct);
    }
    
    // Get single product by ID
    @Override
    public ProductResponse getProductById(String id) {
        return productRepository.findById(id)
                .map(this::toProductResponse)
                .orElseThrow(() ->
                        new ProductNotFoundException("Product not found with ID: " + id)
                );
    }
    
    // Get all products (consider pagination for production)
    // consider Pagination. (page,size) to reduce a massive call as this scales.
    @Override
    public List<ProductResponse> getAllProducts() {
        List<Product> products = productRepository.findAll();
        if (products.isEmpty()) {
            throw new ProductNotFoundException("No products found.");
        }
        return products.stream()
                .map(this::toProductResponse)
                .collect(Collectors.toList());
    }
    
    // Update product (seller only)
    @Override
    public ProductResponse updateProduct(String id, UpdateProductRequest request, String sellerId) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException("Cannot update ‚Äî Product not found with ID: " + id));
        // BUSINESS RULE:
        // Only owner (seller) can update this product
        if (!product.getUserId().equals(sellerId)) {
            throw new ForbiddenException("Unauthorized: You do not own this product");
        }
        
//        // Validate business logic on incoming changes
//        if (request.getPrice() != null && request.getPrice() < 0) {
//            throw new BadRequestException("Price must be non-negative.");
//        }
//        if (request.getQuantity() != null && request.getQuantity() < 0) {
//            throw new BadRequestException("Quantity must be zero or greater.");
//        }
        
        // Prevent changing to a name that already exists for same seller (conflict)
        if (request.getName() != null && !request.getName().equals(product.getName())) {
            List<Product> existing = productRepository.findByUserId(sellerId)
                    .stream()
                    .filter(p -> p.getName().equalsIgnoreCase(request.getName()) && !p.getId().equals(product.getId()))
                    .collect(Collectors.toList());
            if (!existing.isEmpty()) {
                throw new ConflictException("Product with name already exists for seller.");
            }
        }
        
        // Update fields if provided
        if (request.getName() != null) product.setName(request.getName());
        if (request.getDescription() != null) product.setDescription(request.getDescription());
        if (request.getPrice() != null) product.setPrice(request.getPrice());
        if (request.getQuantity() != null) product.setQuantity(request.getQuantity());
        if (request.getCategoryId() != null) product.setCategoryId(request.getCategoryId());
        if (request.getImages() != null) product.setImages(request.getImages());

        Product updatedProduct = productRepository.save(product);
//        ProductUpdatedEvent event = ProductUpdatedEvent.builder()
//                .productId(updatedProduct.getId())
//                .sellerId(sellerId)
//                .name(updatedProduct.getName())
//                .price(updatedProduct.getPrice())
//                .build();
        // kafkaTemplate.send(productUpdatedTopic, event)
        //         .whenComplete((result, ex) -> {
        //             if (ex != null) {
        //                 log.error("Failed to publish event", ex);
        //             } else {
        //                 log.info("Event published: " + event);
        //             }
        //         });
        return toProductResponse(updatedProduct);
    }
    
    // Delete product (seller only)
    @Override
    @Transactional
    public void deleteProduct(String id, String sellerId) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException("Cannot delete ‚Äî Product not found with ID: " + id));
        // BUSINESS RULE:
        // Only owner (seller) can delete this product
        if (!product.getUserId().equals(sellerId)) {
            throw new ForbiddenException("Unauthorized: You do not own this product");
        }
        productRepository.deleteById(id);
        
        ProductDeletedEvent event = ProductDeletedEvent.builder()
                .productId(product.getId())
                .sellerId(sellerId)
                .build();
         kafkaTemplate.send(productDeletedTopic, event)
                 .whenComplete((result, ex) -> {
                     if (ex != null) {
                         log.error("Failed to publish event", ex);
                     } else {
                         log.info("Event published: " + event);
                     }
                 });

    }
    
    // Get all products by seller (for seller dashboard)
    @Override
    public List<ProductResponse> getProductsBySeller(String sellerId) {
        List<Product> products = productRepository.findByUserId(sellerId);
        // Do NOT throw on empty; just map to DTOs
        // if (products.isEmpty()) {
        //     throw new ProductNotFoundException("No products found for seller: " + sellerId);
        // }
        return products.stream().map(this::toProductResponse).collect(Collectors.toList());
    }
    
    @Override
    public org.springframework.data.domain.Page<ProductResponse> searchProducts(
            String keyword, 
            java.math.BigDecimal minPrice, 
            java.math.BigDecimal maxPrice, 
            String categoryId, 
            org.springframework.data.domain.Pageable pageable) {
        
        String searchKey = (keyword == null || keyword.trim().isEmpty()) ? "" : keyword;
        java.math.BigDecimal minP = (minPrice == null) ? java.math.BigDecimal.ZERO : minPrice;
        java.math.BigDecimal maxP = (maxPrice == null) ? new java.math.BigDecimal("9999999") : maxPrice;
        
        return productRepository.findByFacetedSearch(searchKey, minP, maxP, categoryId, pageable)
            .map(this::toProductResponse);
    }
    
    @Override
    @Transactional  // MongoDB single-doc ACID
    public void reserveStock(String productId, int quantity, String orderNumber) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new BadRequestException("Product not found: " + productId));  // Use BadRequest for client errors
        
        if (product.getQuantity() < quantity) {
            throw new BadRequestException(
                    String.format("Insufficient stock. Available: %d, Requested: %d",
                            product.getQuantity(), quantity));
        }
        
        product.setQuantity(product.getQuantity() - quantity);
        productRepository.save(product);
        
        // Create & save reservation (TTL=30min=1800s handled by @Indexed) (Check Reservation.java for time)
        Reservation reservation = Reservation.builder()
                .productId(productId)
                .quantity(quantity)
                .orderNumber(orderNumber)
                .createdAt(LocalDateTime.now())
                .build();
        reservationRepository.save(reservation);
        
        log.info("Reserved {} units of {} (order={})", quantity, productId, orderNumber);
    }
    
    @Override
    @Transactional
    public void releaseStock(String productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new BadRequestException("Product not found: " + productId));
        
        // Allow oversell recovery (quantity may be negative from partial txns)
        product.setQuantity(product.getQuantity() + quantity);
        productRepository.save(product);
        
        log.info("Released {} units of {}", quantity, productId);
    }
    
    @Override
    @Transactional
    public void commitReservations(String orderNumber) {
        // Bulk delete ALL reservations for this order (multi-product support)
        reservationRepository.deleteByOrderNumber(orderNumber);
        log.info("Committed reservations for orderNumber={}", orderNumber);
    }
    
    
    
    // Helper: Map Product entity to ProductResponse DTO
    private ProductResponse toProductResponse(Product product) {
        return ProductResponse.builder()
                .id(product.getId())
                .name(product.getName())
                .description(product.getDescription())
                .price(product.getPrice())
                .images(product.getImages())
                .quantity(product.getQuantity())
                .userId(product.getUserId()) // Correct getter
                .categoryId(product.getCategoryId())
                .build();
    }
}
```

#### Repositories
##### CategoryRepository.java
```java
package com.buyone.productservice.repository;

import com.buyone.productservice.model.Category;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.List;

public interface CategoryRepository extends MongoRepository<Category, String> {
}
```

##### ProductRepository.java
```java
package com.buyone.productservice.repository;

import com.buyone.productservice.model.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;

import java.math.BigDecimal;
import java.util.List;

public interface ProductRepository extends MongoRepository<Product, String> {
    List<Product> findByUserId(String userId);
    void deleteByUserId(String userId);
    
    @Query("{ $and: [ " +
           "{ $or: [ " +
           "  { 'name': { $regex: ?0, $options: 'i' } }, " +
           "  { 'description': { $regex: ?0, $options: 'i' } }" +
           "] }, " +
           "{ 'price': { $gte: ?1, $lte: ?2 } }, " +
           "{ $or: [ " +
           "  { 'categoryId': ?3 }, " +
           "  { $expr: { $eq: [?3, null] } } " +
           "] } " +
           "] }")
    Page<Product> findByFacetedSearch(
        String keyword, 
        BigDecimal minPrice, 
        BigDecimal maxPrice, 
        String categoryId, 
        Pageable pageable
    );
}
```

##### ReservationRepository.java
```java
package com.buyone.productservice.repository;

import com.buyone.productservice.model.Reservation;
import org.springframework.data.mongodb.repository.MongoRepository;

public interface ReservationRepository extends MongoRepository<Reservation, String> {
    void deleteByOrderNumber(String orderNumber);  // Bulk delete
}
```

#### Models/DTOs (Top 10)
##### Category.java
```java
package com.buyone.productservice.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder

@Document("categories")
public class Category {
    @Id
    private String id;
    private String slug;
    private String name;
    private String icon;
    private String description;
}
```

##### Product.java
```java
package com.buyone.productservice.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.math.BigDecimal;


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder

@Document(collection = "products")
public class Product {
    @Id
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer quantity;
    private String userId;
    private String categoryId;
    private java.util.List<String> images;
}```

##### Reservation.java
```java
package com.buyone.productservice.model;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import java.time.LocalDateTime;

@Data
@Builder
@Document("reservations")
public class Reservation {
    @Id private String id;
    private String productId;
    private int quantity;
    private String orderNumber;
    
    @Indexed(expireAfterSeconds = 60)  // 1 min auto-delete; uses seconds
    private LocalDateTime createdAt;
}
```

---

### üü¢ user-service

#### pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.8</version>
        <relativePath/>
    </parent>

    <groupId>com.buyone</groupId>
    <artifactId>user-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>User service</name>
    <description>Handles user registration, profiles, and authentication</description>

    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2022.0.5</spring-cloud.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.30</version>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-ui</artifactId>
            <version>1.7.0</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.3</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.30</version>
                        </path>
                    </annotationProcessorPaths>
                    <release>${java.version}</release>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### Controllers
##### AuthController.java
```java
package com.buyone.userservice.auth;

import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;

import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.request.LoginRequest;
import com.buyone.userservice.response.LoginResponse;
import com.buyone.userservice.auth.AuthService;


@RestController
@RequestMapping("/auth")
public class AuthController {
    private final AuthService authService;
    
    public AuthController(AuthService authService) {
        this.authService = authService;
    }
    
    @PostMapping("/register")
    public ResponseEntity<UserResponse> register(@RequestBody @Valid RegisterUserRequest request) {
        UserResponse created = authService.register(request);
        return ResponseEntity.status(201).body(created); // "201 Created" on success
    }
    
    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestBody @Valid LoginRequest request) {
        LoginResponse response = authService.login(request); // includes token, message, and UserResponse
        return ResponseEntity.ok(response); // "200 OK" with login payload
    }
}
```

##### UserController.java
```java
package com.buyone.userservice.controller;

import com.buyone.userservice.model.Role;
import com.buyone.userservice.request.UpdateUserRequest;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.service.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.security.Principal;
import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    // ---------------------- //
    
    // GET /api/users/{id} - Find user by ID (admin/internal)
    @GetMapping("/{id}")
    public ResponseEntity<UserResponse> getUserById(@PathVariable String id) {
        UserResponse user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
    
    // GET /api/users - List all users (admin/internal)
    @GetMapping
    public ResponseEntity<List<UserResponse>> getAllUsers() {
        List<UserResponse> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }
    
    // GET /me - current user profile
    @GetMapping("/me")
    public ResponseEntity<UserResponse> getCurrentUser(Principal principal) {
        String email = principal.getName();
        UserResponse user = userService.getUserByEmail(email);
        return ResponseEntity.ok(user);
    }
    
    @GetMapping("/sellers")
    public ResponseEntity<List<UserResponse>> getSellers() {
        return ResponseEntity.ok(userService.getUsersByRole(Role.SELLER));
    }
    
    @GetMapping("/clients")
    public ResponseEntity<List<UserResponse>> getClients() {
        return ResponseEntity.ok(userService.getUsersByRole(Role.CLIENT));
    }
    
    // ---------------------- //
    
    // PUT /me - update current user profile
    @PutMapping("/me")
    public ResponseEntity<UserResponse> updateCurrentUser(
            Principal principal,
            @Valid @RequestBody UpdateUserRequest updateUserRequest) {
        String email = principal.getName();
        UserResponse updated = userService.updateUserByEmail(email, updateUserRequest);
        return ResponseEntity.ok()
            .header("X-Email-Update", "Email changes require admin privileges")
            .body(updated);
    }

    // PUT /api/users/{id} - Update user info (admin/internal)
    @PutMapping("/{id}")
    public ResponseEntity<UserResponse> updateUser(
            @PathVariable String id,
            @Valid @RequestBody UpdateUserRequest updateUserRequest) {
        UserResponse updated = userService.updateUser(id, updateUserRequest);
        return ResponseEntity.ok(updated);
    }
    
    // DELETE /api/users/{id} - Delete user by ID (admin/internal)
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable String id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}



```

#### Services
##### UserServiceApplication.java
```java
package com.buyone.userservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class UserServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(UserServiceApplication.class, args);
	}

}
```

##### AuthService.java
```java
package com.buyone.userservice.auth;

import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.request.LoginRequest;
import com.buyone.userservice.response.LoginResponse;
import com.buyone.userservice.response.UserResponse;

public interface AuthService {
    UserResponse register(RegisterUserRequest registerRequest);
    LoginResponse login(LoginRequest loginRequest);
}
```

##### AuthServiceImpl.java
```java
package com.buyone.userservice.auth;

import com.buyone.userservice.model.User;
import com.buyone.userservice.repository.UserRepository;
import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.request.LoginRequest;
import com.buyone.userservice.response.LoginResponse;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.exception.BadRequestException;
import com.buyone.userservice.exception.ConflictException;
import com.buyone.userservice.exception.ResourceNotFoundException;
import com.buyone.userservice.exception.AuthException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class AuthServiceImpl implements AuthService {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;
    
    public AuthServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder, JwtUtil jwtUtil) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.jwtUtil = jwtUtil;
    }
    
    @Override
    public UserResponse register(RegisterUserRequest registerRequest) {
        // validate and check for duplicate email, etc.
        if (userRepository.findByEmail(registerRequest.getEmail()).isPresent()) {
            throw new ConflictException("Email already exists");
        }
        User user = User.builder()
                .name(registerRequest.getName())
                .email(registerRequest.getEmail())
                .password(passwordEncoder.encode(registerRequest.getPassword()))
                .role(registerRequest.getRole())
                .avatar(registerRequest.getAvatar())
                .build();
        userRepository.save(user);
        return new UserResponse(user.getId(), user.getName(), user.getEmail(), user.getRole(), user.getAvatar());
    }
    
    @Override
    public LoginResponse login(LoginRequest loginRequest) {
        User user = userRepository.findByEmail(loginRequest.getEmail())
                .orElseThrow(() -> new ResourceNotFoundException("No user found with email: " + loginRequest.getEmail()));
        if (!passwordEncoder.matches(loginRequest.getPassword(), user.getPassword())) {
            throw new AuthException("Invalid email or password");
        }
        String roleType = user.getRole().name(); // changing role (enum) to string
        String token = jwtUtil.generateToken(user.getId(),user.getEmail(), roleType);
        return new LoginResponse("Login successful", token,
                new UserResponse(user.getId(), user.getName(), user.getEmail(), user.getRole(), user.getAvatar()));
    }
}
```

##### UserService.java
```java
package com.buyone.userservice.service;

import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.request.UpdateUserRequest;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.model.User;
import com.buyone.userservice.model.Role;

import java.util.List;
import java.util.Optional;

public interface UserService {
    // Creation
    UserResponse createUser(RegisterUserRequest request);
    
    // Queries for API (DTOs)
    UserResponse getUserById(String id);
    UserResponse getUserByEmail(String email);
    
    List<UserResponse> getAllUsers();
    List<UserResponse> getUsersByRole(Role role);
    
    // Updates
    UserResponse updateUser(String id, UpdateUserRequest request);              // admin/internal
    UserResponse updateUserByEmail(String email, UpdateUserRequest request);   // for /me
    
    // Internal lookups (entities, not exposed to controllers)
    Optional<User> getUserEntityByEmail(String email);
    User getUserEntityById(String id);
    
    // Deletion
    void deleteUser(String id);
}


// Methods should use DTOs for incoming and outgoing data (except for internal lookups).```

##### UserServiceImpl.java
```java
package com.buyone.userservice.service;

import com.buyone.userservice.model.User;
import com.buyone.userservice.model.Role;
import com.buyone.userservice.repository.UserRepository;
import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.request.UpdateUserRequest;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.exception.BadRequestException;
import com.buyone.userservice.exception.ConflictException;
import com.buyone.userservice.exception.ResourceNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class UserServiceImpl implements UserService {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }
    
    // Creation //
    @Override
    public UserResponse createUser(RegisterUserRequest request) {
        if (request.getEmail() == null || request.getEmail().isBlank()) {
            throw new BadRequestException("Email cannot be empty");
        }
        if (userRepository.findByEmail(request.getEmail()).isPresent()) {
            throw new ConflictException("Email already exists: " + request.getEmail());
        }
        if (request.getPassword() == null || request.getPassword().isBlank()) {
            throw new BadRequestException("Password cannot be empty");
        }
        
        User user = User.builder()
                .name(request.getName())
                .email(request.getEmail())
                .password(passwordEncoder.encode(request.getPassword()))
                .role(request.getRole())
                .avatar(request.getAvatar())
                .build();
        
        User savedUser = userRepository.save(user);
        return toUserResponse(savedUser);
    }

    
    // -------------------------- //
    
    // for DTOs
    
    @Override
    public UserResponse getUserById(String id) {
        return userRepository.findById(id)
                .map(this::toUserResponse)
                .orElseThrow(
                        () -> new ResourceNotFoundException("User not found with ID " + id)
                );
    }
    
    @Override
    public UserResponse getUserByEmail(String email) {
        if (email == null || email.isBlank()) {
            throw new BadRequestException("Email must not be empty");
        }
        return userRepository.findByEmail(email)
                .map(this::toUserResponse)
                .orElseThrow(() ->
                        new ResourceNotFoundException("No user found with email: " + email)
                );
    }
    
    @Override
    public List<UserResponse> getAllUsers() {
        List<User> users = userRepository.findAll();
        if (users.isEmpty()) {
            throw new ResourceNotFoundException("No users found");
        }
        return users.stream()
                .filter(u -> u.getEmail() != null && u.getRole() != null)
                .map(this::toUserResponse)
                .collect(Collectors.toList());
    }
    
    @Override
    public List<UserResponse> getUsersByRole(Role role) {
        return userRepository.findByRole(role)
                .stream()
                .map(this::toUserResponse)
                .collect(Collectors.toList());
    }
    
    
    // -------------------------- //
    
    // updates
    @Override
    public UserResponse updateUser(String id, UpdateUserRequest request) {
        User existingUser = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + id));
        if (request.getEmail() != null && userRepository.findByEmail(request.getEmail()).isPresent()
                && !request.getEmail().equals(existingUser.getEmail())) {
            throw new ConflictException("Email already exists: " + request.getEmail());
        }
        
        if (request.getName() != null ) {
            existingUser.setName(request.getName());
        }
        if (request.getEmail() != null) {
            existingUser.setEmail(request.getEmail());
        }
        if (request.getPassword() != null && !request.getPassword().isBlank()) {
            existingUser.setPassword(passwordEncoder.encode(request.getPassword()));
        }
        if (request.getRole() != null) {
            existingUser.setRole(request.getRole());
        }

        // Always set avatar from request (can be null to clear)
        existingUser.setAvatar(request.getAvatar()); // may be null -> clears avatar   
            
        User updatedUser = userRepository.save(existingUser);
        return toUserResponse(updatedUser);
    }
    
    @Override
    public UserResponse updateUserByEmail(String email, UpdateUserRequest request) {
        if (email == null || email.isBlank()) {
            throw new BadRequestException("Email must not be empty");
        }
        
        User existingUser = userRepository.findByEmail(email)
                .orElseThrow(() ->
                        new ResourceNotFoundException("No user found with email: " + email)
                );
        
        // Decide allowed fields for self-update (no role change, maybe no email change)
        if (request.getName() != null) {
            existingUser.setName(request.getName());
        }
        if (request.getPassword() != null && !request.getPassword().isBlank()) {
            existingUser.setPassword(passwordEncoder.encode(request.getPassword()));
        }
        existingUser.setAvatar(request.getAvatar()); // may be null -> clears avatar
        // if you want to allow email change via /me, handle it carefully & check uniqueness
        
        User updatedUser = userRepository.save(existingUser);
        return toUserResponse(updatedUser);
    }
    
    // -------------------------- //
    
    // for internal lookup
    @Override
    public Optional<User> getUserEntityByEmail(String email) {
        if (email == null || email.isBlank()) {
            throw new BadRequestException("Email must not be empty");
        }
        return userRepository.findByEmail(email);
    }
    
    @Override
    public User getUserEntityById(String id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + id));
    }
    
    // -------------------------- //
    
    // Deletion
    
    @Override
    @Transactional
    public void deleteUser(String id) {
        if (!userRepository.existsById(id)) {
            throw new ResourceNotFoundException("Cannot delete ‚Äî user not found with ID: " + id);
        }
        // Cascade deletes/logic for related entities if needed
        userRepository.deleteById(id);
    }
    
    // -------------------------- //
    
    // Mapping helper
    private UserResponse toUserResponse(User user) {
        return UserResponse.builder()
                .id(user.getId())
                .name(user.getName())
                .email(user.getEmail())
                .role(user.getRole())
                .avatar(user.getAvatar())
                .build();
    }
}
```

#### Repositories
##### UserRepository.java
```java
package com.buyone.userservice.repository;

import com.buyone.userservice.model.User;
import com.buyone.userservice.model.Role;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.Optional;
import java.util.List;

public interface UserRepository extends MongoRepository<User, String> {
    Optional<User> findByEmail(String email);
    List<User> findByRole(Role role);
}
```

#### Models/DTOs (Top 10)
##### Role.java
```java
package com.buyone.userservice.model;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;

public enum Role {
    CLIENT,
    SELLER;
    
    @JsonCreator
    public static Role fromString(String value) {
        if (value == null) return null;
        return Role.valueOf(value.trim().toUpperCase());
    }
    
    @JsonValue
    public String toValue() {
        return name();
    }
}
```

##### User.java
```java
package com.buyone.userservice.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Data               // shortcut to combining @Getter, @Setter, @ToString, and @EqualsAndHashCode
@NoArgsConstructor  // generates a constructor with no arguments (empty body).
@AllArgsConstructor // Generates a constructor with one argument for every field in the class.
@Builder            // implements Builder pattern
                    // User user = User.builder().name("Joon").email(j@k.kr").password("pw").build()

@Document(collection = "users")
public class User {
    @Id
    private String id;
    private String name;
    private String email;
    private String password;
    private Role role;
    private String avatar;
}
```

---

## ‚öõÔ∏è FRONTEND (Angular)

### package.json
```json
{
  "name": "grit-tee",
  "version": "0.0.0",
  "browserslist": [
    "last 2 Chrome versions",
    "last 2 Firefox versions",
    "last 2 Safari versions",
    "last 2 Edge versions",
    "Firefox ESR",
    "not dead"
  ],
  "scripts": {
    "ng": "ng",
    "start": "ng serve --proxy-config proxy.conf.json",
    "start:no-proxy": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "lint": "eslint src --ext .ts,.js",
    "format": "prettier --write \"src/**/*.{ts,js,html,css,scss}\""
  },
  "prettier": {
    "printWidth": 100,
    "singleQuote": true,
    "overrides": [
      {
        "files": "*.html",
        "options": {
          "parser": "angular"
        }
      }
    ]
  },
  "private": true,
  "engines": {
    "node": ">=22.12.0"
  },
  "dependencies": {
    "@angular/animations": "^20.3.10",
    "@angular/cdk": "^20.2.12",
    "@angular/common": "^20.3.0",
    "@angular/compiler": "^20.3.0",
    "@angular/core": "^20.3.0",
    "@angular/forms": "^20.3.0",
    "@angular/material": "^20.2.12",
    "@angular/platform-browser": "^20.3.0",
    "@angular/router": "^20.3.0",
    "bootstrap": "^5.3.8",
    "bootstrap-icons": "^1.13.1",
    "chart.js": "^4.5.1",
    "chartjs-plugin-datalabels": "^2.2.0",
    "ng2-charts": "^6.0.1",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.15.0"
  },
  "devDependencies": {
    "@angular-eslint/eslint-plugin": "^21.0.1",
    "@angular/build": "^20.3.6",
    "@angular/cli": "^21.1.0",
    "@angular/compiler-cli": "^20.3.0",
    "@types/jasmine": "~5.1.0",
    "@typescript-eslint/parser": "^8.48.0",
    "baseline-browser-mapping": "^2.9.14",
    "eslint": "^9.39.1",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "jasmine-core": "~5.9.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "karma-junit-reporter": "^2.0.1",
    "prettier": "^3.6.2",
    "typescript": "~5.9.2"
  }
}
```

### angular.json (key parts)
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "grit-tee": {
      "projectType": "application",
      "schematics": {},
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular/build:application",
          "options": {
            "browser": "src/main.ts",
            "polyfills": [
              "zone.js"
            ],
            "tsConfig": "tsconfig.app.json",
            "assets": [
              "src/favicon.ico",
              "src/assets",
              {
                "glob": "**/*",
## üß™ API TESTS (Bruno)

### bruno.json
```json
{
  "version": "1",
  "name": "buy-two-api",
  "type": "collection",
  "ignore": [
    "node_modules",
    ".git"
  ]
}```
## üèóÔ∏è INFRA & DOCUMENTATION

### README.md
```
# Safe Zone - Microservices CI/CD Pipeline

Complete automated CI/CD pipeline with Jenkins and SonarQube code quality analysis.

# Project Overview

**Backend Services** (Spring Boot + Maven):
- Discovery Service (service registry)
- Gateway Service (API gateway)
- User Service (user management)
- Product Service (product catalog)
- Media Service (media handling)

**Frontend** (Angular + npm):
- Web UI for the Safe Zone application

**CI/CD Pipeline**:
- Automated builds and tests
- Code quality analysis with SonarQube
- Docker image building
- Automated deployment
- Slack notifications

# Prerequisites

- Docker (version 20.10+)
- Docker Compose (version 1.29+)
- Ports 9090 (Jenkins) and 9000 (SonarQube) available
- 4GB RAM minimum

# Installation & Startup

### Step 1: Start SonarQube (First - it takes longer to initialize)
````
docker-compose -f sonarqube-compose.yml up -d
````

- Wait 60 seconds for SonarQube to initialize.

- URL: http://localhost:9000

>Username: admin
Password: admin

### Step 2: Start Jenkins (Second - it will auto-connect to SonarQube)

````
docker-compose up -d
````
- Wait 60 seconds for Jenkins to start and automatically connect to SonarQube network.

- URL: http://localhost:9090

>Initial Setup: First login will prompt for initial password (check docker logs jenkins)

## Running the Pipeline
- Open Jenkins: http://localhost:9090

- Select the safe-zone pipeline job

- Click "Build Now"

- Monitor the pipeline in Pipeline Overview

Pipeline Stages
The build will execute these stages automatically:

````
‚úì Checkout                                    (get code from Git)
  ‚îú‚îÄ ‚úì Backend Build - discovery-service
  ‚îú‚îÄ ‚úì Backend Build - gateway-service
  ‚îú‚îÄ ‚úì Backend Build - user-service
  ‚îú‚îÄ ‚úì Backend Build - product-service
  ‚îî‚îÄ ‚úì Backend Build - media-service
  
  ‚îú‚îÄ ‚úì Backend Tests - discovery-service
  ‚îú‚îÄ ‚úì Backend Tests - gateway-service
  ‚îú‚îÄ ‚úì Backend Tests - user-service
  ‚îú‚îÄ ‚úì Backend Tests - product-service
  ‚îî‚îÄ ‚úì Backend Tests - media-service
  
  ‚îî‚îÄ ‚úì Frontend - Tests Included
  
  ‚îú‚îÄ ‚úì SonarQube Analysis - Backend          (analyzes all 5 services)
  ‚îî‚îÄ ‚úì SonarQube Analysis - Frontend         (analyzes Angular app)
  
  ‚îú‚îÄ ‚úì Build Images                          (Docker image building)
  ‚îú‚îÄ ‚úì Deploy & Verify                       (deployment + health checks)
  ‚îî‚îÄ ‚úì Post Actions                          (Slack notifications)
  ````
Build Time: Approximately 2-3 minutes for full pipeline

## Viewing Results
#### Jenkins Pipeline
- URL: http://localhost:9090/job/safe-zone/

- View all builds, logs, and stage details

- Click on any build number to see details

#### SonarQube Code Quality
- URL: http://localhost:9000/projects

- Projects Analyzed:

    - Safe Zone - Discovery Service

    - Safe Zone - Gateway Service

    - Safe Zone - User Service

    - Safe Zone - Product Service

    - Safe Zone - Media Service

    - Safe Zone - Frontend

- Each project shows:

    - ‚úÖ Code quality metrics

    - ‚úÖ Security vulnerabilities

    - ‚úÖ Code coverage

    - ‚úÖ Maintainability ratings

    - ‚úÖ Test coverage

# Architecture
### Docker Network Setup
Jenkins and SonarQube are automatically connected via the java-jenk_sonarnet Docker network:

- Jenkins Container: jenkins (http://jenkins:8080 internally)

- SonarQube Container: sonarqube (http://sonarqube:9000 internally)

- Database Container: sonarqube-db (PostgreSQL)

- Network: java-jenk_sonarnet (bridge network)

>Key: No manual docker network connect commands needed - fully automated in docker-compose.yml

### How Jenkins Talks to SonarQube
Inside the pipeline, Jenkins:

1. Compiles Java code with Maven ‚Üí generates target/classes

2. Runs tests ‚Üí generates test reports

3. Executes sonar-scanner with compiled classes

4. Sends analysis to SonarQube via: http://sonarqube:9000 (internal Docker DNS)

5. SonarQube stores results in PostgreSQL database

6. Results visible in SonarQube dashboard

### Configuration Files
- docker-compose.yml (Jenkins)
````
services:
  jenkins:
    build: .                              # Builds from Dockerfile
    networks:
      - java-jenk_sonarnet              # Auto-connects to SonarQube network
`````

- sonarqube-compose.yml (SonarQube)
````
services:
  sonarqube:
    image: sonarqube:community
    networks:
      - java-jenk_sonarnet
  sonarqube-db:
    image: postgres:15-alpine
    networks:
      - java-jenk_sonarnet

networks:
  java-jenk_sonarnet:
    driver: bridge
`````

- Jenkinsfile (Pipeline Definition)
    - Defines all pipeline stages

    - Configures SonarQube Scanner

    - Sets up Maven builds and tests

    - Handles Docker image building

    - Manages deployment and notifications

# Troubleshooting
### 1. Containers won't start
````
# Check logs
```

### B02-Task.md
```
# Task description

## Overview

In this project, you will finalize a full e-commerce web application by adding core features: shopping cart, orders, user & seller profiles with analytics, and product search/filtering.
You‚Äôll integrate work from previous projects (auth, product/media, microservices) and enforce best practices: PR workflows, CI/CD (Jenkins), and code quality (SonarQube).

## Role Play

You are a full-stack engineer wrapping up the marketplace for launch.
Your mission: deliver a secure, performant, and user-friendly experience from browsing ‚Üí cart ‚Üí checkout ‚Üí order tracking, with clean code, CI/CD, and clear documentation.

## Learning Objectives

- Design and extend data models for carts, orders, and profiles

- Implement RESTful APIs for carts, orders, search, and analytics

- Build Angular views (cart, checkout, order history, dashboards)

- Add search & filtering (text + facets) with efficient querying

- Apply error handling, validation, and role-based security

- Practice team workflows (PRs, reviews) and CI/CD with Jenkins

- Measure and improve code quality using SonarQube

- Write tests (unit, integration, e2e) for critical flows

## Instructions

### Database Design

Extend your existing schema (MongoDB collections or SQL tables‚Äîconsistent with prior work)

### Best Practices Ecosystem Familiarity

- Create feature branches; open PRs for every change.

- Perform code reviews (security, performance, readability).

- Use Jenkins: pipeline stages = build ‚Üí test ‚Üí quality gate ‚Üí package ‚Üí deploy to staging.

- Protect main branch: require approved reviews and green pipeline.

### API Development Enhancement

Orders MicroService:

- Implement orders page to follow the order status.

- List the orders for both users and sellers using a search functionality.

- Implement orders management to remove, cancel, or redo orders.

User Profile:

- Develop a user profile section where users can see their best products, most buying products, and how much money they spent.

- Develop a seller profile section where they can see their best-selling products and how much money they gained.

Search and Filtering:

- Implement search functionality that enables users to search for products based on keywords.

- Add filtering options to refine product searches.

Shopping Cart Implementation:

- Create a shopping cart functionality that allows users to add products to their cart.

- Enable users to complete the purchase of the selected products in the shopping cart by selecting the "pay on delivery" feature.

Code Quality and Best Practices:

- Utilize SonarQube to ensure code quality and adherence to best practices.

- Address any code quality issues reported by SonarQube in your PRs.

- Document the improvements made based on SonarQube feedback.

Front-End Development with Angular

- Cart & Checkout

  - Cart page (list, qty edit, remove, subtotal/total).

  - Checkout wizard (address ‚Üí review ‚Üí confirm "Pay on Delivery").

- Orders

  - Order list with search (status/date).

  - Order details page with status timeline and totals.

- Profiles

  - User dashboard: total spent, most bought, top categories (charts).

  - Seller dashboard: revenue, best-selling products, units sold (charts).

- Search & Filtering

  - Product search page with keyword bar, filters (category, price sliders), sort, pagination.

- UX/Tech

  - Angular route guards (auth), HTTP interceptors (token, 401/403), Reactive Forms, responsive layout (Angular Material/Bootstrap).

Error Handling & Validation

- Backend: global exception handlers; consistent error schema { code, message, details }.

- Common statuses: 400 validation, 401/403 auth, 404 missing, 409 conflicts, avoid unhandled 5xx.

- Frontend: display inline form errors, snackbars/toasts for API failures, optimistic UI where safe.

Security Measures

- Reuse prior security setup: JWT/OAuth2, role checks, ownership enforcement.

- Protect sensitive data (no secrets in responses, mask PII where needed).

- Enforce HTTPS, secure cookies (if used), CORS at gateway.

- Server-side checks for: user vs seller capabilities, order ownership, and mutable status rules.

## Constraints

- Must implement: Cart, Orders, Profiles (analytics), Search/Filter, Pay on Delivery.

- Keep public endpoints read-only (e.g., product search); all mutations require auth.

- Pipeline must include tests + SonarQube quality gate.

## Evaluation

- üõí Cart & Checkout: add/update/remove items; create order with Pay on Delivery.

- üì¶ Orders: list/search, details, cancel/redo; seller can list related orders.

- üë§ Profiles & Analytics: user spend & most bought; seller revenue & best sellers.

- üîé Search/Filters: keyword + facets with pagination.

- üé® UX: responsive, accessible, clear flows.

- üß™ Testing: unit/integration/e2e for critical paths.

- üîê Security & Robustness: proper authZ, no unhandled 5xx.

- üß≠ Process: PRs, reviews, green CI, SonarQube issues addressed.

## Bonus (Optional)

- Wishlist (save for later).

- Additional payment methods (simulate gateway integration).

## Resources

- Backend

  - Spring Boot & REST: https://spring.io/guides

  - Spring Security (JWT/OAuth2): https://spring.io/projects/spring-security

- Data & Search

  - MongoDB Docs: https://www.mongodb.com/docs/

  - (Optional) Elasticsearch: https://www.elastic.co/guide/

- Frontend

  - Angular Docs: https://angular.io/docs

  - Angular Material: https://material.angular.io/

- Pipeline & Quality

  - Jenkins Pipelines: https://www.jenkins.io/doc/pipeline/tour/getting-started/

  - SonarQube: https://docs.sonarsource.com/sonarqube/

## Audit

#### Functional

##### Verify that the necessary tables, fields, relations are added.

- Has the database design been correctly implemented?

- Have the students added new relationships and have they used them correctly?

- Did the students convince you with their additions to the database?

##### Review the project repository to check for PRs and code reviews.

```

### POSTMAN_TESTING_GUIDE.md
```
# Postman API Testing Guide - Error Response Validation

## Base Configuration

**Base URL (Gateway)**: `https://localhost:8080`  
**Note**: Gateway uses SSL, you may need to disable SSL verification in Postman

---

## 1. Authentication Flow (Get JWT Token)

### ‚úÖ Register New User (Successful)
```
POST https://localhost:8080/auth/register

Headers:
Content-Type: application/json

Body (JSON):
{
  "name": "John Seller",
  "email": "john.seller@example.com",
  "password": "password123",
  "role": "SELLER"
}

Expected Success Response (201):
{
  "id": "...",
  "name": "John Seller",
  "email": "john.seller@example.com",
  "role": "SELLER",
  ...
}
```

### ‚úÖ Login (Get JWT Token)
```
POST https://localhost:8080/auth/login

Headers:
Content-Type: application/json

Body (JSON):
{
  "email": "john.seller@example.com",
  "password": "password123"
}

Expected Success Response (200):
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "message": "Login successful",
  "user": {
    "id": "...",
    "name": "John Seller",
    "email": "john.seller@example.com",
    "role": "SELLER"
  }
}

‚ö†Ô∏è SAVE THE TOKEN - You'll need it for authenticated requests!
```

---

## 2. Error Responses Testing

### üî¥ 400 Bad Request - Validation Errors

#### Test 1: Missing Required Fields (Product Creation)
```
POST https://localhost:8080/products

Headers:
Content-Type: application/json
Authorization: Bearer <your-jwt-token>

Body (JSON) - INVALID:
{
  "description": "A product without name or price"
}

Expected Error Response (400):
{
  "code": "400",
  "message": "Validation failed",
  "details": {
    "name": "Product name is required",
    "price": "Price is required",
    "quantity": "Quantity is required"
  }
}
```

#### Test 2: Invalid Field Values (User Registration)
```
POST https://localhost:8080/auth/register

Headers:
Content-Type: application/json

Body (JSON) - INVALID:
{
  "name": "A",
  "email": "not-an-email",
  "password": "short",
  "role": "SELLER"
}

Expected Error Response (400):
{
  "code": "400",
  "message": "Validation failed",
  "details": {
    "name": "Name must be between 2 and 40 characters",
    "email": "Invalid email format",
    "password": "Password must be between 8 and 24 characters"
  }
}
```

#### Test 3: Invalid Price/Quantity (Product Creation)
```
POST https://localhost:8080/products

Headers:
Content-Type: application/json
Authorization: Bearer <your-jwt-token>

Body (JSON) - INVALID:
{
  "name": "Test Product",
  "price": -10.50,
  "quantity": -5
}

Expected Error Response (400):
{
  "code": "400",
  "message": "Validation failed",
  "details": {
    "price": "Price must be at least 0.01",
    "quantity": "Quantity must be at least 1"
  }
}
```

#### Test 3b: Zero or Decimal Quantity (Product Creation)
```
POST https://localhost:8080/products

Headers:
Content-Type: application/json
Authorization: Bearer <your-jwt-token>

Body (JSON) - INVALID:
{
  "name": "Test Product",
  "price": 29.99,
  "quantity": 0
}

Expected Error Response (400):
{
  "code": "400",
  "message": "Validation failed",
  "details": {
    "quantity": "Quantity must be at least 1"
  }
}

Note: Decimal values like 0.11 will be rejected by type validation since quantity is Integer.
```

### üî¥ 401 Unauthorized - Missing/Invalid Token

#### Test 4: Access Protected Route Without Token
```
POST https://localhost:8080/products

Headers:
Content-Type: application/json
(NO Authorization header)

Body (JSON):
{
  "name": "Test Product",
  "price": 100,
  "quantity": 10
}

Expected Error Response (401):
{
  "code": "401",
  "message": "Unauthorized: JWT token is missing or invalid",
  "details": null
}
```

```

### docker-compose.yml
```
# version: '3.8'

x-common-env: &common-env
  EUREKA_CLIENT_SERVICE-URL-DEFAULTZONE: http://discovery-service:8761/eureka/
  SPRING_DATA_MONGODB_URI: ${ATLAS_URI}
  KAFKA_BOOTSTRAP_SERVERS: kafka:9092
  SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_SECRET: ${SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_SECRET}
  KEY_STORE_PASSWORD: ${KEY_STORE_PASSWORD} 

services:
  # === INFRA ===
  kafka:
    image: confluentinc/cp-kafka:7.6.1
    ports:
      - "9092:9092"
    environment:
      CLUSTER_ID: "5FpdX8jhTLOoQasxFvMBmg"
      KAFKA_PROCESS_ROLES: broker,controller
      KAFKA_NODE_ID: 1
      KAFKA_CONTROLLER_QUORUM_VOTERS: "1@kafka:9093"
      KAFKA_LISTENERS: "PLAINTEXT://:9092,CONTROLLER://:9093"
      KAFKA_ADVERTISED_LISTENERS: "PLAINTEXT://kafka:9092"
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: "PLAINTEXT:PLAINTEXT,CONTROLLER:PLAINTEXT"
      KAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
      KAFKA_NUM_PARTITIONS: 3
    volumes:
      - kafka_data:/var/lib/kafka/data

  # === DISCOVERY (starts first) ===
  discovery-service:
    build:
      context: ./backend/discovery-service
    image: discovery-service:${IMAGE_TAG:-latest}
    container_name: discovery-service-${IMAGE_TAG:-latest}
    ports: ["8761:8761"]
    env_file:
      - .env
    environment:
      SPRING_PROFILES_ACTIVE: docker
    volumes:
      - maven-repo:/root/.m2

  # === GATEWAY ===
  gateway-service:
    build: ./backend/gateway-service
    image: gateway-service:${IMAGE_TAG:-latest}
    container_name: gateway-service-${IMAGE_TAG:-latest}
    ports: ["8080:8080"]
    depends_on:
      - discovery-service
    env_file:
      - .env
    environment:
      <<: *common-env
      SERVER_PORT: 8080
    volumes:
      - maven-repo:/root/.m2

  # === BUSINESS SERVICES ===
  user-service:
    build: ./backend/user-service
    image: user-service:${IMAGE_TAG:-latest}
    container_name: user-service-${IMAGE_TAG:-latest}
    depends_on:
      - discovery-service
    env_file:
      - .env
    environment:
      <<: *common-env
      SPRING_DATA_MONGODB_DATABASE: ${USER_DB:-userdb}
      SERVER_PORT: 8456
    volumes:
      - maven-repo:/root/.m2

  product-service:
    build: ./backend/product-service
    image: product-service:${IMAGE_TAG:-latest}
    container_name: product-service-${IMAGE_TAG:-latest}
    depends_on:
      - discovery-service
      - kafka
    env_file:
      - .env
    environment:
      <<: *common-env
      SPRING_DATA_MONGODB_DATABASE: ${PRODUCT_DB:-productdb}
      SERVER_PORT: 8567
    volumes:
      - maven-repo:/root/.m2

  media-service:
    build: ./backend/media-service
    image: media-service:${IMAGE_TAG:-latest}
    container_name: media-service-${IMAGE_TAG:-latest}
    depends_on:
      - discovery-service
      - kafka
    env_file:
      - .env
    environment:
      <<: *common-env
      SPRING_DATA_MONGODB_DATABASE: ${MEDIA_DB:-mediadb}
      CLOUDFLARE_R2_ENDPOINT: ${R2_ENDPOINT}
      CLOUDFLARE_R2_ACCESS_KEY: ${R2_ACCESS_KEY}
      CLOUDFLARE_R2_SECRET_KEY: ${R2_SECRET_KEY}
      SERVER_PORT: 8678
    volumes:
      - maven-repo:/root/.m2

  order-service:
    build: ./backend/order-service
    image: order-service:${IMAGE_TAG:-latest}
    container_name: order-service-${IMAGE_TAG:-latest}
    ports: [ "8789:8789" ]
    depends_on:
      - discovery-service
      - kafka
    env_file:
      - .env
    environment:
      <<: *common-env
      SPRING_DATA_MONGODB_DATABASE: ${ORDER_DB:-orderdb}
      SERVER_PORT: 8789
    volumes:
      - maven-repo:/root/.m2

  # === FRONTEND ===
  frontend:
    build: ./frontend
    image: frontend:${IMAGE_TAG:-latest}
    container_name: frontend-${IMAGE_TAG:-latest}
    ports: ["4200:443"]
    depends_on: [gateway-service]

  # CRASH TEST (no build)
  # frontend:
  #   image: frontend:v999-broken-nonexistent
  #   container_name: frontend-v999-broken
  #   ports: ["4200:443"]
  #   depends_on: [gateway-service]

volumes:
  kafka_data:
  maven-repo:
```

### Jenkinsfile
```
pipeline {
	agent any

	/**********************
	 * Prevent concurrent builds
	 **********************/
	options {
		disableConcurrentBuilds()
		timestamps()
		timeout(time: 1, unit: 'HOURS')
	}

	/**********************
	 * Global configuration
	 **********************/
	parameters {
		string(name: 'BRANCH', defaultValue: 'main', description: 'Branch to build')
	}

	environment {
		// Credentials
		SLACK_WEBHOOK = credentials('slack-webhook')
		BRANCH = "${env.BRANCH_NAME ?: env.GIT_BRANCH ?: params.BRANCH ?: 'main'}"

		// Image versioning
		VERSION    = "v${env.BUILD_NUMBER}"
		STABLE_TAG = "stable"

		// Shared Maven repo on the agent disk
		MAVEN_REPO_LOCAL = "${env.JENKINS_HOME}/.m2/repository"
		// Optional: shared npm cache
		NPM_CONFIG_CACHE = "${env.JENKINS_HOME}/.npm"
	}

	tools {
		maven 'maven-3.9'
		nodejs 'node-20.19.6'
	}

	stages {

		/************
		 * Checkout *
		 ************/
		stage('Checkout') {
			steps {
				checkout([
					$class: 'GitSCM',
					branches: [[name: "*/${params.BRANCH}"]],
					userRemoteConfigs: [[
						url: 'https://github.com/kurizma/safe-zone.git',
						credentialsId: 'safe-zone'
					]]
				])
			}
		}

		/*************************
		 * Backend build (no tests)
		 *************************/
		stage('Backend Build - discovery-service') {
			steps {
				dir('backend/discovery-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} clean package -DskipTests"
				}
			}
		}

		stage('Backend Build - gateway-service') {
			steps {
				dir('backend/gateway-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} clean package -DskipTests"
				}
			}
		}

		stage('Backend Build - user-service') {
			steps {
				dir('backend/user-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} clean package -DskipTests"
				}
			}
		}

		stage('Backend Build - product-service') {
			steps {
				dir('backend/product-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} clean package -DskipTests"
				}
			}
		}

		stage('Backend Build - media-service') {
			steps {
				dir('backend/media-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} clean package -DskipTests"
				}
			}
		}

		/***********************
		 * Backend unit tests  *
		 ***********************/
		stage('Backend Tests - discovery-service') {
			steps {
				dir('backend/discovery-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} test"
				}
			}
		}

		stage('Backend Tests - gateway-service') {
			steps {
				dir('backend/gateway-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} test"
				}
			}
		}

		stage('Backend Tests - user-service') {
			steps {
				dir('backend/user-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} test"
				}
			}
		}

		stage('Backend Tests - product-service') {
			steps {
				dir('backend/product-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} test"
				}
			}
		}

		stage('Backend Tests - media-service') {
			steps {
				dir('backend/media-service') {
					sh "mvn -Dmaven.repo.local=${MAVEN_REPO_LOCAL} test"
				}
			}
		}

		/************
		 * Frontend *
		 ************/
		stage('Frontend - Tests Included') {
			steps {
				dir('frontend') {
					// nodejs(nodeJSInstallationName: 'node-20.19.6')
					sh 'npm ci'
					sh 'npm test -- --watch=false --browsers=ChromeHeadlessNoSandbox --no-progress'
					sh 'ls -la test-results/junit/ || echo "No test-results dir"'
					sh 'npx ng build --configuration production'
				}
			}
		}

		/************
		 * Test Failure Handling ‚Üí Early Slack ‚Üí Skip Sonar/deploy ‚Üí Post FAILURE *
		 ************/
		stage('Test Summary') {
			steps {
				script {
					def testFailed = false
					def cleanBranch = "${BRANCH ?: GIT_BRANCH ?: 'main'}".replaceAll(/^origin\//, '')
					try {
						sh 'find . -name "*.xml" -path "*/surefire-reports/*.xml" | head -1 && echo "Tests passed" || testFailed = true'
					} catch (e) {
						testFailed = true
					}
					if (testFailed) {
						withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_WEBHOOK')]) {
							sh '''
                                curl -sS -X POST -H "Content-type: application/json" --data "{
                                    \\"text\\": \\":x: TESTS FAILED!\\n*Job:* ${JOB_NAME}\\n*Build:* ${BUILD_NUMBER}\\n*Branch:* ${cleanBranch}
                                }" "${SLACK_WEBHOOK}"
                            '''
						}
						error "Tests failed - aborting deploy"
					}
				}
			}
		}

		/****************************
		* SonarQube Code Analysis *
		****************************/
		stage('SonarQube Analysis - Backend') {
			steps {
				script {
					def scannerHome = tool name: 'SonarQube Scanner', type: 'hudson.plugins.sonar.SonarRunnerInstallation'
					env.PATH = "${scannerHome}/bin:${env.PATH}"

					withSonarQubeEnv('SonarQube Dev') {
						withCredentials([string(credentialsId: 'sonarqube-token', variable: 'SONAR_TOKEN'),
							string(credentialsId: 'sonarqube-host-url', variable: 'SONAR_HOST')]) {
							dir('backend/discovery-service') {
								sh '''
                                    sonar-scanner \
```

## ‚úÖ COMPLETE DUMP READY
Upload to NotebookLM/Perplexity for analysis
