--- FILE: backend/discovery-service/src/main/java/com/buyone/discovery_service/DiscoveryServiceApplication.java ---
package com.buyone.discovery_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class DiscoveryServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(DiscoveryServiceApplication.class, args);
	}

}
-e 
--- END FILE: backend/discovery-service/src/main/java/com/buyone/discovery_service/DiscoveryServiceApplication.java ---

--- FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/config/GatewayDebugConfig.java ---
package com.buyone.gatewayservice.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.cloud.gateway.filter.factory.GatewayFilterFactory;

@Configuration
public class GatewayDebugConfig implements ApplicationListener<ContextRefreshedEvent> {
    
    private final ListableBeanFactory beanFactory;
    
    public GatewayDebugConfig(ListableBeanFactory beanFactory) {
        this.beanFactory = beanFactory;
    }
    
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        System.out.println("=== GatewayFilterFactory beans ===");
        beanFactory.getBeansOfType(GatewayFilterFactory.class)
                .forEach((name, bean) ->
                        System.out.println("Factory bean: " + name + " -> " + bean.getClass().getName()));
        System.out.println("=== END ===");
    }
}-e 
--- END FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/config/GatewayDebugConfig.java ---

--- FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/config/SecurityConfig.java ---
package com.buyone.gatewayservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.http.HttpMethod;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsConfigurationSource;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import org.springframework.security.config.Customizer;
import org.springframework.security.web.server.context.NoOpServerSecurityContextRepository;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                        .pathMatchers("/auth/**").permitAll()
                        .pathMatchers(HttpMethod.GET, "/products/**").permitAll()
                        .pathMatchers(HttpMethod.GET, "/categories/**").permitAll()
                        .pathMatchers(HttpMethod.GET, "/media/images/**").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/users/**").permitAll()
                        
                        // Cart
                        .pathMatchers("/api/cart/**").authenticated()
                        
                        // Order
                        .pathMatchers("/api/orders/**").authenticated()
                        
                        // Analyrics
                        .pathMatchers("/api/analytics/**").authenticated()
                        
                        .pathMatchers("/actuator/health").permitAll()
                        .anyExchange().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(Customizer.withDefaults())
                );
        
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOriginPatterns(List.of(
                "http://localhost:4200",
                "https://localhost:4200",
                "http://localhost:*"  // Allow any local port during development
        ));
        config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        config.setAllowedHeaders(Arrays.asList("*"));
        config.setExposedHeaders(List.of("Authorization"));
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
-e 
--- END FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/config/SecurityConfig.java ---

--- FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/config/JwtDecoderConfig.java ---
package com.buyone.gatewayservice.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;

import javax.crypto.spec.SecretKeySpec;

@Configuration
public class JwtDecoderConfig {
    
    @Value("${spring.security.oauth2.resourceserver.jwt.secret}")
    private String jwtSecret;
    
    @Bean
    public ReactiveJwtDecoder jwtDecoder() {
        return NimbusReactiveJwtDecoder.withSecretKey(
                new SecretKeySpec(jwtSecret.getBytes(), "HmacSHA256")
        ).build();
    }
}
-e 
--- END FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/config/JwtDecoderConfig.java ---

--- FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/GatewayServiceApplication.java ---
package com.buyone.gatewayservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class GatewayServiceApplication {
 
	public static void main(String[] args) {
		SpringApplication.run(GatewayServiceApplication.class, args);
	}

}
-e 
--- END FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/GatewayServiceApplication.java ---

--- FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/filter/JwtHeaderGatewayFilterFactory.java ---
package com.buyone.gatewayservice.filter;

import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;

@Component
public class JwtHeaderGatewayFilterFactory extends AbstractGatewayFilterFactory<JwtHeaderGatewayFilterFactory.Config> {

    public JwtHeaderGatewayFilterFactory() {
        super(Config.class);
    }
    
    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) ->
                exchange.getPrincipal()
                        .cast(JwtAuthenticationToken.class)
                        .map(auth -> {
                            Jwt jwt = auth.getToken();
                            String userId = jwt.getClaimAsString("id");
                            String role = jwt.getClaimAsString("role");
                            ServerHttpRequest request = exchange.getRequest()
                                    .mutate()
                                    .header("X-USER-ID", userId)
                                    .header("X-USER-ROLE", role)
                                    .build();
                            return exchange.mutate().request(request).build();
                        })
                        .defaultIfEmpty(exchange)
                        .flatMap(chain::filter);
    }
    
    public static class Config {} // no custom config
}
-e 
--- END FILE: backend/gateway-service/src/main/java/com/buyone/gatewayservice/filter/JwtHeaderGatewayFilterFactory.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/repository/MediaRepository.java ---
package com.buyone.mediaservice.repository;

import com.buyone.mediaservice.model.Media;
import com.buyone.mediaservice.model.MediaOwnerType;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.List;

public interface MediaRepository extends MongoRepository<Media, String> {
    long countByOwnerIdAndOwnerType(String ownerId, MediaOwnerType ownerType);
    List<Media> findAllByOwnerIdAndOwnerType(String ownerId, MediaOwnerType ownerType);
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/repository/MediaRepository.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/listener/ProductEventListener.java ---
package com.buyone.mediaservice.listener;

import com.buyone.mediaservice.model.MediaOwnerType;
import com.buyone.mediaservice.repository.MediaRepository;
import com.buyone.mediaservice.service.StorageService;
import com.buyone.productservice.event.ProductDeletedEvent;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.context.annotation.Profile;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class ProductEventListener {
    
    private final MediaRepository mediaRepository;
    private final StorageService storageService;
    
    @KafkaListener(
            topics = "${app.kafka.topic.product-deleted}",
            groupId = "media-service"
    )
    public void onProductDeleted(ProductDeletedEvent event) {
        log.info("üóëÔ∏è Cleaning up images for product: {}", event.getProductId());
        // Find all media for this product
        var medias = mediaRepository.findAllByOwnerIdAndOwnerType(
                event.getProductId(),
                MediaOwnerType.PRODUCT
        );
        
        for (var media : medias) {
            try {
                storageService.delete(media.getImagePath());
                mediaRepository.deleteById(media.getId());
                log.info("‚úÖ Deleted image: {}", media.getId());  // ADD LOG
            } catch (Exception e) {
                log.error("‚ùå Failed to delete image {}: {}", media.getId(), e.getMessage());
            }
        }
        log.info("‚úÖ Product cleanup complete: {}", event.getProductId());  // ADD LOG
    }
        // Optional: log or produce audit event
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/listener/ProductEventListener.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/MediaServiceApplication.java ---
package com.buyone.mediaservice;

import org.springframework.boot.SpringApplication;
import com.buyone.mediaservice.config.CloudflareR2Properties;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@SpringBootApplication
@EnableConfigurationProperties(CloudflareR2Properties.class)
public class MediaServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(MediaServiceApplication.class, args);
	}

}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/MediaServiceApplication.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/ApiResponse.java ---
package com.buyone.mediaservice.response;

import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/ApiResponse.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/MediaResponse.java ---
package com.buyone.mediaservice.response;

import java.time.Instant;

public record MediaResponse(
        String id,
        String ownerId,
        String url,          // e.g. /media/images/{id}
        Instant createdAt
) {}-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/MediaResponse.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/ErrorResponse.java ---
package com.buyone.mediaservice.response;

import java.time.Instant;

public record ErrorResponse(
        Instant timestamp,
        int status,
        String error,
        String message,
        String path
) {}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/ErrorResponse.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/DeleteMediaResponse.java ---
package com.buyone.mediaservice.response;

public record DeleteMediaResponse(String mediaId, String message) {}

-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/DeleteMediaResponse.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/MediaListResponse.java ---
package com.buyone.mediaservice.response;

import java.util.List;

public record MediaListResponse(List<MediaResponse> images, int count, int maxImages) {}

-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/response/MediaListResponse.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/SecurityConfig.java ---
package com.buyone.mediaservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        System.out.println("!!! MediaService SecurityConfig loaded with JWT !!!");
        
        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints (no auth needed)
                        .requestMatchers(HttpMethod.GET, "/media/images/**").permitAll()
                        .requestMatchers(HttpMethod.GET, "/media/**").permitAll()
                        // Actuator health for startup script
                        .requestMatchers("/actuator/health").permitAll()

                        // All writes require authentication (we can refine to ROLE_SELLER later)
                        .requestMatchers(HttpMethod.POST, "/media/**").authenticated()
                        .requestMatchers(HttpMethod.PUT, "/media/**").authenticated()
                        .requestMatchers(HttpMethod.DELETE, "/media/**").authenticated()
                        
                        // All other requests require authentication
                        .anyRequest().authenticated()
                )
                // Tell Spring this is a JWT resource server
                .oauth2ResourceServer(oauth2 -> oauth2.jwt());
        
        return http.build();
    }
    
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/SecurityConfig.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/CloudflareR2Properties.java ---
package com.buyone.mediaservice.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;

//the what

@Data
@ConfigurationProperties(prefix = "cloudflare.r2")
public class CloudflareR2Properties {
    
    private String accessKeyId;
    private String secretAccessKey;
    private String region;
    private String endpoint;
    private String bucket;
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/CloudflareR2Properties.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/CloudflareR2Config.java ---
package com.buyone.mediaservice.config;

import java.net.URI;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import com.buyone.mediaservice.config.CloudflareR2Properties;


// the HOW

@Configuration
@EnableConfigurationProperties(CloudflareR2Properties.class)
@RequiredArgsConstructor
public class CloudflareR2Config {
    
    private final CloudflareR2Properties props;
    
    @Bean
    public S3Client r2S3Client() {
        AwsBasicCredentials credentials = AwsBasicCredentials.create(
                props.getAccessKeyId(),
                props.getSecretAccessKey()
        );
        
        return S3Client.builder()
                .credentialsProvider(StaticCredentialsProvider.create(credentials))
                .region(Region.of(props.getRegion())) // "auto" for R2 [web:12][web:32]
                .endpointOverride(URI.create(props.getEndpoint())) // https://<account>.r2.cloudflarestorage.com [web:6][web:32]
                .build();
    }
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/CloudflareR2Config.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/S3Config.java ---
package com.buyone.mediaservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;

@Configuration
public class S3Config {
    
    @Bean
    public S3Client s3Client() {
        return S3Client.builder()
                .region(Region.of("us-east-1")) // Change to your region!
                .credentialsProvider(DefaultCredentialsProvider.create())
                .build();
    }
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/S3Config.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/JwtConfig.java ---
package com.buyone.mediaservice.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;

import javax.crypto.spec.SecretKeySpec;

@Configuration
public class JwtConfig {

    @Value("${spring.security.oauth2.resourceserver.jwt.secret}")
    private String jwtSecret;
    
    @Bean
    public JwtDecoder jwtDecoder() {
        // Use the same raw bytes that user-service uses for signing
        byte[] keyBytes = jwtSecret.getBytes();
        SecretKeySpec secretKey = new SecretKeySpec(keyBytes, "HmacSHA256");
        return NimbusJwtDecoder.withSecretKey(secretKey).build();
    }
    
}-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/config/JwtConfig.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/security/SecurityUtils.java ---
package com.buyone.mediaservice.security;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Component;

@Component
public class SecurityUtils {
    
    public String getCurrentUserId() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.getPrincipal() instanceof Jwt jwt) {
            return jwt.getSubject(); // 'sub' from JWT, which user-service set as email
        }
        return null;
    }
    
    public String getCurrentUserRole() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.getPrincipal() instanceof Jwt jwt) {
            return jwt.getClaimAsString("role"); // exactly as user-service sets it
        }
        return null;
    }
    
    public boolean isCurrentUserSeller() {
        String role = getCurrentUserRole();
        return "SELLER".equalsIgnoreCase(role);
    }
    
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/security/SecurityUtils.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/controller/MediaController.java ---
package com.buyone.mediaservice.controller;

import com.buyone.mediaservice.model.Media;
import com.buyone.mediaservice.request.MediaUploadRequest;
import com.buyone.mediaservice.response.MediaResponse;
import com.buyone.mediaservice.response.MediaListResponse;
import com.buyone.mediaservice.response.DeleteMediaResponse;
import com.buyone.mediaservice.response.ApiResponse;
import com.buyone.mediaservice.service.MediaService;
import com.buyone.mediaservice.service.StorageService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.http.ResponseEntity;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;

import java.util.List;

@RestController
@RequestMapping("/media/images")
@RequiredArgsConstructor
public class MediaController {
    
    private final MediaService mediaService;
    private final StorageService storageService;
    // use @Value or service constant and put into yml
    private static final int MAX_IMAGES_PER_PRODUCT = 5;
    
    @GetMapping("/product/{productId}")
    public ResponseEntity<ApiResponse<MediaListResponse>> listMediaForProduct(@PathVariable String productId) {
        List<MediaResponse> responses = mediaService.mediaListForProduct(productId);
        MediaListResponse payload = new MediaListResponse(responses, responses.size(), MAX_IMAGES_PER_PRODUCT);
        ApiResponse<MediaListResponse> response = ApiResponse.<MediaListResponse>builder()
                .success(true)
                .data(payload)
                .build();
        return ResponseEntity.ok(response);
    }
    
    //    Right now, your getMedia is perfect for APIs (Angular) to fetch metadata,
    //    but to actually display the avatar image in <img>,
    //    you‚Äôll eventually need an endpoint that returns image/jpeg bytes.
    //    For now, conceptually:
    //    Yes: GET /media/images/{mediaId} is the avatar metadata call.
    
    // get metadata for specific media file, ex. Avatar
    @GetMapping("/{mediaId}")
    public ResponseEntity<ApiResponse<MediaResponse>> getMedia(@PathVariable String mediaId) {
        MediaResponse media = mediaService.getMedia(mediaId);
        ApiResponse<MediaResponse> response = ApiResponse.<MediaResponse>builder()
                .success(true)
                .data(media)
                .build();
        return ResponseEntity.ok(response);
    }
    
    // raw image api
    @GetMapping("/{mediaId}/file")
    public ResponseEntity<Resource> getImageFile(@PathVariable String mediaId) {
        Media media = mediaService.findMediaEntity(mediaId); // or reuse getMedia + repo
        Resource resource = storageService.loadAsResource(media.getImagePath());
        
        return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_JPEG) // or detect from file/metadata
                .body(resource);
    }
    
    
    
    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<ApiResponse<MediaResponse>> uploadImage(
            @Valid @ModelAttribute MediaUploadRequest request,
            @RequestHeader("X-USER-ID") String currentUserId,
            @RequestHeader("X-USER-ROLE") String currentUserRole
    ) {
        MediaResponse media = mediaService.uploadImage(
                request.getFile(),
                request.getOwnerId(),
                request.getOwnerType(),
                currentUserId,
                currentUserRole
        );
        ApiResponse<MediaResponse> response = ApiResponse.<MediaResponse>builder()
                .success(true)
                .message("Image uploaded successfully")
                .data(media)
                .build();
        return ResponseEntity.status(201).body(response);
    }
    
    @PutMapping(value = "/{mediaId}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<ApiResponse<MediaResponse>> updateMedia(
            @PathVariable String mediaId,
            @RequestParam("file") MultipartFile file,
            @RequestHeader("X-USER-ID") String currentUserId,
            @RequestHeader("X-USER-ROLE") String currentUserRole
    ) {
        MediaResponse media = mediaService.updateMedia(file, mediaId, currentUserId, currentUserRole);
        ApiResponse<MediaResponse> response = ApiResponse.<MediaResponse>builder()
                .success(true)
                .message("Image updated successfully")
                .data(media)
                .build();
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{mediaId}")
    public ResponseEntity<ApiResponse<DeleteMediaResponse>>  deleteMedia(@PathVariable String mediaId,
            @RequestHeader("X-USER-ID") String currentUserId,
            @RequestHeader("X-USER-ROLE") String currentUserRole
    ) {
        DeleteMediaResponse deleted = mediaService.deleteMedia(mediaId, currentUserId, currentUserRole);
        ApiResponse<DeleteMediaResponse> response = ApiResponse.<DeleteMediaResponse>builder()
                .success(true)
                .message("Deleted successfully")
                .data(deleted)
                .build();
        return ResponseEntity.ok(response);
    }
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/controller/MediaController.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/model/Media.java ---
package com.buyone.mediaservice.model;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Document("media")
public class Media {
    
    @Id
    private String id;
    private String ownerId; // userId or productId
    private MediaOwnerType ownerType; // USER or PRODUCT
    private String imagePath;   // where the file is stored (relative path or URL)
    
    @CreatedDate
    private Instant createdAt;
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/model/Media.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/model/MediaOwnerType.java ---
package com.buyone.mediaservice.model;

public enum MediaOwnerType {
    USER,
    PRODUCT
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/model/MediaOwnerType.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/request/MediaUploadRequest.java ---
package com.buyone.mediaservice.request;

import com.buyone.mediaservice.model.MediaOwnerType;
import jakarta.validation.constraints.*;
import lombok.Data;
import org.springframework.web.multipart.MultipartFile;

@Data
public class MediaUploadRequest {
    
    @NotNull(message = "File is required")
    private MultipartFile file;
    
    @NotBlank(message = "Owner ID is required")
    private String ownerId;
    
    @NotNull(message = "Owner type is required")
    private MediaOwnerType ownerType;
}-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/request/MediaUploadRequest.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/service.impl/MediaServiceImpl.java ---
package com.buyone.mediaservice.service.impl; 

import com.buyone.mediaservice.model.Media;
import com.buyone.mediaservice.model.MediaOwnerType;
import com.buyone.mediaservice.repository.MediaRepository;
import com.buyone.mediaservice.response.MediaResponse;
import com.buyone.mediaservice.response.DeleteMediaResponse;
import com.buyone.mediaservice.service.MediaService;
import com.buyone.mediaservice.service.StorageService;
import com.buyone.mediaservice.exception.MediaNotFoundException;
import com.buyone.mediaservice.exception.InvalidFileException;
import com.buyone.mediaservice.exception.ConflictException;
import com.buyone.mediaservice.exception.ForbiddenException;
import lombok.RequiredArgsConstructor;

import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.beans.factory.annotation.Value;

import java.time.Instant;
import java.util.List;

@Service
@RequiredArgsConstructor
public class MediaServiceImpl implements MediaService {
    
    private final MediaRepository mediaRepository;
    private final StorageService storageService;
    
    private static final int MAX_IMAGES_PER_PRODUCT = 5;
    private static final long MAX_FILE_SIZE_BYTES = 2L * 1024 * 1024;

    @Value("${app.media.public-base-url}")
    private String publicBucketBaseUrl;
    
    @Override
    public MediaResponse uploadImage(MultipartFile file,
                                    String ownerId,
                                    MediaOwnerType ownerType,
                                    String currentUserId,
                                    String currentUserRole) {
        validateImageFile(file);
        boolean isSeller = "SELLER".equals(currentUserRole);
        boolean isClient = "CLIENT".equals(currentUserRole);

        // For USER avatars: allow both SELLER and CLIENT,
        //    but only for their own user id
        if (ownerType == MediaOwnerType.USER) {
            if (!(isSeller || isClient)) {
                throw new ForbiddenException("Only Sellers and Clients can upload user avatars.");
            }
            if (!ownerId.equals(currentUserId)) {
                throw new ForbiddenException("You can only upload an avatar for yourself.");
            }
        }
        // For PRODUCT images: only SELLER role allowed
        if (ownerType == MediaOwnerType.PRODUCT && !isSeller) {
            throw new ForbiddenException("Only Seller can upload product images.");
        }

        // If this is a user avatar, ensure only one avatar per user
        if (ownerType == MediaOwnerType.USER) {
            List<Media> existingAvatar = mediaRepository.findAllByOwnerIdAndOwnerType(ownerId, MediaOwnerType.USER);
            for (Media m : existingAvatar) {
                storageService.delete(m.getImagePath());
                mediaRepository.delete(m);
            }
        }

        // If this is a product image, enforce max 5 images per product
        if (ownerType == MediaOwnerType.PRODUCT) {
            long imageCount = mediaRepository.countByOwnerIdAndOwnerType(ownerId, MediaOwnerType.PRODUCT);
            if (imageCount >= MAX_IMAGES_PER_PRODUCT) {
                throw new ConflictException("This product already has the maximum number of images (" + MAX_IMAGES_PER_PRODUCT + ").");
            }
        }
    
        
        Media media = Media.builder()
                .ownerId(ownerId)
                .ownerType(ownerType)
                .createdAt(Instant.now())
                .build();
        
        media = mediaRepository.save(media);
        
        // store() should return something like "media/<id>.png"
        String imagePath = storageService.store(file, media.getId());
        
        media.setImagePath(imagePath);
        media = mediaRepository.save(media);
        
        // Public Cloudflare URL, e.g. https://pub-....r2.dev/media/<id>.png
        String url = publicBucketBaseUrl + "/" + imagePath;
        
        return new MediaResponse(
                media.getId(),
                media.getOwnerId(),
                url,
                media.getCreatedAt()
        );
    }
    
    @Override
    public MediaResponse getMedia(String id) {
        Media media = mediaRepository.findById(id)
                .orElseThrow(() -> new MediaNotFoundException(id));
        // Public Cloudflare URL, e.g. https://pub-....r2.dev/media/<id>.png
        String url = publicBucketBaseUrl + "/" + media.getImagePath();
        return new MediaResponse(
                media.getId(),
                media.getOwnerId(),
                url,
                media.getCreatedAt()
        );
    }
    
    @Override
    public MediaResponse updateMedia(MultipartFile file,
                                    String mediaId,
                                    String currentUserId,
                                    String currentUserRole) {
        validateImageFile(file);
        
        if (!"SELLER".equals(currentUserRole)) {
            throw new ForbiddenException("Only sellers can update images.");
        }
        
        Media media = mediaRepository.findById(mediaId)
                .orElseThrow(() -> new MediaNotFoundException(mediaId));
        
        // Ownership: only ownerId can update this media
        if (!media.getOwnerId().equals(currentUserId)) {
            throw new ForbiddenException("You can only update your own media.");
        }
        
        
        storageService.delete(media.getImagePath());
        
        String newImagePath = storageService.store(file, media.getId());
        
        media.setImagePath(newImagePath);
        media.setCreatedAt(Instant.now());
        
        media = mediaRepository.save(media);
        
        // Public Cloudflare URL, e.g. https://pub-....r2.dev/media/<id>.png
        String url = publicBucketBaseUrl + "/" + newImagePath;
        
        return new MediaResponse(
                media.getId(),
                media.getOwnerId(),
                url,
                media.getCreatedAt()
        );
    }
    
    @Override
    public DeleteMediaResponse deleteMedia(String id,
                                        String currentUserId,
                                        String currentUserRole) {
        boolean isSeller = "SELLER".equals(currentUserRole);
        boolean isClient = "CLIENT".equals(currentUserRole);

        Media media = mediaRepository.findById(id)
                .orElseThrow(() -> new MediaNotFoundException(id));

        // USER avatars: owner can delete their own avatar (CLIENT or SELLER)
        if (media.getOwnerType() == MediaOwnerType.USER) {
            if (!media.getOwnerId().equals(currentUserId)) {
                throw new ForbiddenException("You can only delete your own avatar.");
            }
            if (!(isSeller || isClient)) {
                throw new ForbiddenException("Only Sellers or Clients can delete user avatars.");
            }   
        }

        // PRODUCT images: only SELLER allowed, and must be owner
        if (media.getOwnerType() == MediaOwnerType.PRODUCT) {
            if (!isSeller) {
                throw new ForbiddenException("Only sellers can delete product images.");
            }
            if (!media.getOwnerId().equals(currentUserId)) {
                throw new ForbiddenException("You can only delete your own product images.");
            }
        }

        // if (!"SELLER".equals(currentUserRole)) {
        //     throw new ForbiddenException("Only sellers can delete images.");
        // }
        
        // ‚úÖ CRITICAL: Ownership check FIRST
        // if (!media.getOwnerId().equals(currentUserId)) {
        //     throw new ForbiddenException("You can only delete your own media.");
        // }
        
        // ‚úÖ Role check: CLIENT can delete OWN avatar, SELLER can delete anything
        // if (media.getOwnerType() == MediaOwnerType.USER && !"SELLER".equals(currentUserRole)) {
        //     throw new ForbiddenException("Only sellers can manage user avatars.");
        // }
        
        storageService.delete(media.getImagePath());
        mediaRepository.deleteById(id);
        return new DeleteMediaResponse(id, "Deleted successfully");
    }
    
    @Override
    public List<MediaResponse> mediaListForProduct(String productId) {
        List<Media> medias = mediaRepository.findAllByOwnerIdAndOwnerType(productId, MediaOwnerType.PRODUCT);
        
        return medias.stream()
                .map(m -> new MediaResponse(
                        m.getId(),
                        m.getOwnerId(),
                        publicBucketBaseUrl + "/" + m.getImagePath(),
                        m.getCreatedAt()
                ))
                .toList();
    }
    
    @Override
    public Media findMediaEntity(String id) {
        return mediaRepository.findById(id)
                .orElseThrow(() -> new MediaNotFoundException(id));
    }
    
    private void validateImageFile(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            throw new InvalidFileException("No file provided!");
        }
        if (file.getSize() > MAX_FILE_SIZE_BYTES) {
            throw new InvalidFileException("File exceeds 2MB size limit!");
        }
        String contentType = file.getContentType();
        if (contentType == null || !contentType.startsWith("image/")) {
            throw new InvalidFileException("Only image files are allowed!");
        }
    }
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/service.impl/MediaServiceImpl.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/service.impl/com/buyone/mediaservice/service/impl/StorageServiceImpl.java ---
package com.buyone.mediaservice.service.impl;

import com.buyone.mediaservice.config.CloudflareR2Properties;
import com.buyone.mediaservice.exception.InvalidFileException;
import com.buyone.mediaservice.exception.MediaNotFoundException;
import com.buyone.mediaservice.exception.BadRequestException;
import com.buyone.mediaservice.service.StorageService;
import com.buyone.mediaservice.config.CloudflareR2Properties;
import lombok.RequiredArgsConstructor;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import software.amazon.awssdk.core.ResponseInputStream;
import software.amazon.awssdk.core.sync.RequestBody;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.DeleteObjectRequest;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.GetObjectResponse;
import software.amazon.awssdk.services.s3.model.NoSuchKeyException;
import software.amazon.awssdk.services.s3.model.PutObjectRequest;

import java.io.ByteArrayInputStream;
import java.io.IOException;

@Service
@RequiredArgsConstructor
public class StorageServiceImpl implements StorageService {
    
    private final S3Client r2S3Client;
    private final CloudflareR2Properties props;
    
    @Override
    public String store(MultipartFile file, String mediaId) {
        if (file.isEmpty()) {
            throw new BadRequestException("Cannot store empty file");
        }
        
        long maxBytes = 2L * 1024 * 1024;
        if (file.getSize() > maxBytes) {
            throw new InvalidFileException("File too large, max 2MB");
        }
        
        if (file.getContentType() == null || !file.getContentType().startsWith("image/")) {
            throw new InvalidFileException("Only image/* uploads are allowed");
        }
        
        String originalFilename = file.getOriginalFilename();
        String extension = "";
        if (originalFilename != null && originalFilename.contains(".")) {
            extension = originalFilename.substring(originalFilename.lastIndexOf('.'));
        }
        String key = "media/" + mediaId + extension;
        
        try {
            PutObjectRequest putReq = PutObjectRequest.builder()
                    .bucket(props.getBucket())
                    .key(key)
                    .contentType(file.getContentType())
                    .build();
            
            r2S3Client.putObject(putReq, RequestBody.fromBytes(file.getBytes()));
            return key;
        } catch (IOException e) {
            throw new InvalidFileException("Failed to read uploaded file", e);
        } catch (Exception e) {
            // Any AWS/R2 error while putting object ‚Üí 500 via global handler
            throw new RuntimeException("Failed to store file in R2", e);
        }
    }
    
    @Override
    public Resource loadAsResource(String imagePath) {
        try {
            GetObjectRequest getReq = GetObjectRequest.builder()
                    .bucket(props.getBucket())
                    .key(imagePath)
                    .build();
            
            ResponseInputStream<GetObjectResponse> s3Object =
                    r2S3Client.getObject(getReq);
            
            byte[] bytes = s3Object.readAllBytes();
            return new InputStreamResource(new ByteArrayInputStream(bytes));
        } catch (NoSuchKeyException e) {
            throw new MediaNotFoundException(imagePath);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read object from R2", e);
        }
    }
    
    @Override
    public void delete(String imagePath) {
        try {
            DeleteObjectRequest delReq = DeleteObjectRequest.builder()
                    .bucket(props.getBucket())
                    .key(imagePath)
                    .build();
            r2S3Client.deleteObject(delReq);
        } catch (NoSuchKeyException e) {
            // Up to you: either ignore or signal 404
            throw new MediaNotFoundException(imagePath);
        }
    }
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/service.impl/com/buyone/mediaservice/service/impl/StorageServiceImpl.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/service/MediaService.java ---
package com.buyone.mediaservice.service;

import com.buyone.mediaservice.model.Media;
import com.buyone.mediaservice.model.MediaOwnerType;
import com.buyone.mediaservice.response.MediaResponse;
import com.buyone.mediaservice.response.MediaListResponse;
import com.buyone.mediaservice.response.DeleteMediaResponse;
import org.springframework.web.multipart.MultipartFile;
import java.util.List;

public interface MediaService {
    MediaResponse uploadImage(MultipartFile file,
                              String ownerId,
                              MediaOwnerType ownerType,
                              String currentUserId,
                              String currentUserRole);
    
    MediaResponse getMedia(String id);
    
    MediaResponse updateMedia(MultipartFile file,
                              String mediaId,
                              String currentUserId,
                              String currentUserRole);
    
    DeleteMediaResponse deleteMedia(String id,
                                    String currentUserId,
                                    String currentUserRole);
    
    List<MediaResponse> mediaListForProduct(String productId);
    
    // calling from storage to media
    Media findMediaEntity(String id);
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/service/MediaService.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/service/StorageService.java ---
package com.buyone.mediaservice.service;

import org.springframework.core.io.Resource;
import org.springframework.web.multipart.MultipartFile;

public interface StorageService {
    
    String store(MultipartFile file, String mediaId);
    
    Resource loadAsResource(String imagePath);
    
    void delete(String imagePath);
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/service/StorageService.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/ForbiddenException.java ---
package com.buyone.mediaservice.exception;

public class ForbiddenException extends RuntimeException {
    
    public ForbiddenException() {
        super();
    }
    
    public ForbiddenException(String message) {
        super(message);
    }
    
    public ForbiddenException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ForbiddenException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/ForbiddenException.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/MediaNotFoundException.java ---
package com.buyone.mediaservice.exception;

public class MediaNotFoundException extends RuntimeException {
    public MediaNotFoundException() {
        super();
    }
    public MediaNotFoundException(String id) {
        super("Media not found: " + id);
    }
    public MediaNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    public MediaNotFoundException(Throwable cause) {
        super(cause);
    }
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/MediaNotFoundException.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/InvalidFileException.java ---
package com.buyone.mediaservice.exception;

public class InvalidFileException extends RuntimeException {
    public InvalidFileException() {
        super();
    }
    public InvalidFileException(String message) {
        super(message);
    }
    public InvalidFileException(String message, Throwable cause) {
        super(message, cause);
    }
    public InvalidFileException(Throwable cause) {
        super(cause);
    }
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/InvalidFileException.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/ConflictException.java ---
package com.buyone.mediaservice.exception;

public class ConflictException extends RuntimeException {
    
    public ConflictException() {
        super();
    }
    
    public ConflictException(String message) {
        super(message);
    }
    
    public ConflictException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ConflictException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/ConflictException.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/GlobalExceptionHandler.java ---
package com.buyone.mediaservice.exception;

import com.buyone.mediaservice.response.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.multipart.MaxUploadSizeExceededException;
import jakarta.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.util.stream.Collectors;
import java.time.Instant;


@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // Helper for building structured error responses
    private ResponseEntity<ErrorResponse> buildError(HttpStatus status, String message, String path) {
        ErrorResponse error = new ErrorResponse(
                Instant.now(),
                status.value(),
                status.getReasonPhrase(),
                message,
                path
        );
        return new ResponseEntity<>(error, status);
    }
    
    // 400: Bean validation errors
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex, HttpServletRequest request) {
        String message = ex.getBindingResult().getFieldErrors().stream()
                .map(err -> err.getField() + ": " + err.getDefaultMessage())
                .collect(Collectors.joining(", "));
        return buildError(HttpStatus.BAD_REQUEST, message, request.getRequestURI());
    }
    
    // 400: Custom bad request
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequest(BadRequestException ex, HttpServletRequest request) {
        return buildError(HttpStatus.BAD_REQUEST, ex.getMessage(), request.getRequestURI());
    }
    
    // 400: Custom for invalid file (media-specific)
    @ExceptionHandler(InvalidFileException.class)
    public ResponseEntity<ErrorResponse> handleInvalidFile(InvalidFileException ex, HttpServletRequest request) {
        return buildError(HttpStatus.BAD_REQUEST, ex.getMessage(), request.getRequestURI());
    }
    
    // 413: File too large (Spring built-in)
    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<ErrorResponse> handleMaxUploadSize(MaxUploadSizeExceededException ex, HttpServletRequest request) {
        return buildError(HttpStatus.PAYLOAD_TOO_LARGE, "File exceeds 2MB size limit.", request.getRequestURI());
    }
    
    // 403: Forbidden (custom app-level or Spring Security)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbidden(ForbiddenException ex, HttpServletRequest request) {
        return buildError(HttpStatus.FORBIDDEN, ex.getMessage(), request.getRequestURI());
    }
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        return buildError(HttpStatus.FORBIDDEN, "Access Denied: " + ex.getMessage(), request.getRequestURI());
    }
    
    // 404: Media not found
    @ExceptionHandler(MediaNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleMediaNotFound(MediaNotFoundException ex, HttpServletRequest request) {
        return buildError(HttpStatus.NOT_FOUND, ex.getMessage(), request.getRequestURI());
    }
    
    // 405: HTTP Method not allowed
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowed(HttpRequestMethodNotSupportedException ex, HttpServletRequest request) {
        return buildError(HttpStatus.METHOD_NOT_ALLOWED, "Method Not Allowed: " + ex.getMessage(), request.getRequestURI());
    }
    
    // 409: Conflict
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflict(ConflictException ex, HttpServletRequest request) {
        return buildError(HttpStatus.CONFLICT, ex.getMessage(), request.getRequestURI());
    }
    
    // 500: Fallback for unhandled exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex, HttpServletRequest request) {
        ex.printStackTrace();
        String cause = ex.getCause() != null ? ex.getCause().toString() : "No root cause";
        String fullMessage = (ex.getMessage() != null ? ex.getMessage() : "Unexpected server error")
                + " [" + cause + "]";
        return buildError(HttpStatus.INTERNAL_SERVER_ERROR, fullMessage, request.getRequestURI());
    }
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/GlobalExceptionHandler.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/BadRequestException.java ---
package com.buyone.mediaservice.exception;

public class BadRequestException extends RuntimeException {
    public BadRequestException() {
        super();
    }
    
    public BadRequestException(String message) {
        super(message);
    }
    
    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public BadRequestException(Throwable cause) {
        super(cause);
    }
}-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/mediaservice/exception/BadRequestException.java ---

--- FILE: backend/media-service/src/main/java/com/buyone/productservice/event/ProductDeletedEvent.java ---
package com.buyone.productservice.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductDeletedEvent {
    private String productId;
    private String sellerId;
}
-e 
--- END FILE: backend/media-service/src/main/java/com/buyone/productservice/event/ProductDeletedEvent.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/order/OrderItemResponse.java ---
package com.buyone.orderservice.dto.response.order;

import lombok.Builder;
import lombok.Data;

import java.math.BigDecimal;

@Data
@Builder
public class OrderItemResponse {
    private String productName;
    private String sellerId;
    private BigDecimal price;
    private int quantity;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/order/OrderItemResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/order/OrderResponse.java ---
package com.buyone.orderservice.dto.response.order;

import com.buyone.orderservice.model.Address;
import com.buyone.orderservice.model.order.OrderStatus;
import lombok.Builder;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
public class OrderResponse {
    private String orderNumber;
    private OrderStatus status;
    private BigDecimal total, subtotal, tax;
    private LocalDateTime createdAt;
    private Address shippingAddress;
    private List<OrderItemResponse> items;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/order/OrderResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/ApiResponse.java ---
package com.buyone.orderservice.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/ApiResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/ProductResponse.java ---
package com.buyone.orderservice.dto.response;

import lombok.Data;
import java.math.BigDecimal;
import java.util.List;

@Data
public class ProductResponse {
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer quantity;
    private String userId;      // Maps to sellerId
    private String categoryId;
    private List<String> images;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/ProductResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/cart/CartItemResponse.java ---
// CartItemResponse.java
package com.buyone.orderservice.dto.response.cart;

import lombok.Data;
import lombok.Builder;
import java.math.BigDecimal;

@Data @Builder
public class CartItemResponse {
    String productId;
    String productName;
    String imageUrl;
    String sellerId;
    BigDecimal price;
    int quantity;
    BigDecimal lineTotal;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/cart/CartItemResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/cart/CartResponse.java ---
// CartResponse.java
package com.buyone.orderservice.dto.response.cart;

import lombok.Data;
import lombok.Builder;
import java.math.BigDecimal;
import java.util.List;

@Data @Builder
public class CartResponse {
    String id;
    String userId;
    List<CartItemResponse> items;
    BigDecimal subtotal;
    BigDecimal tax;
    BigDecimal total;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/cart/CartResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/ErrorResponse.java ---
package com.buyone.orderservice.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@Builder
public class ErrorResponse {
    private int status;
    private String error;
    private String message;
    private String path;
    private LocalDateTime timestamp;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/ErrorResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/SellerTotalUnits.java ---
package com.buyone.orderservice.dto.response.analytics;

public record SellerTotalUnits(Integer totalUnits) {}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/SellerTotalUnits.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/ClientAnalyticsResponse.java ---
package com.buyone.orderservice.dto.response.analytics;

import java.math.BigDecimal;
import java.util.List;

public record ClientAnalyticsResponse(
        BigDecimal totalSpent,
        List<ClientMostBought> mostBoughtProducts,
        List<ClientTopCategory> topCategories
) {}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/ClientAnalyticsResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/SellerAnalyticsResponse.java ---
package com.buyone.orderservice.dto.response.analytics;

import java.math.BigDecimal;
import java.util.List;

public record SellerAnalyticsResponse(
        BigDecimal totalRevenue,
        List<SellerBestProduct> bestSellingProducts,
        Integer totalUnitsSold
) {}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/SellerAnalyticsResponse.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/SellerTotalRevenue.java ---
package com.buyone.orderservice.dto.response.analytics;

import java.math.BigDecimal;

public record SellerTotalRevenue(BigDecimal totalRevenue) {}  // _id null
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/SellerTotalRevenue.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/SellerBestProduct.java ---
package com.buyone.orderservice.dto.response.analytics;

import java.math.BigDecimal;

public record SellerBestProduct(String productId, String name, BigDecimal revenue, Integer unitsSold) {}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/SellerBestProduct.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/ClientMostBought.java ---
package com.buyone.orderservice.dto.response.analytics;

public record ClientMostBought(String productId, String name, Integer totalQty) {}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/ClientMostBought.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/ClientTotalSpent.java ---
package com.buyone.orderservice.dto.response.analytics;

import java.math.BigDecimal;

public record ClientTotalSpent(String userId, BigDecimal totalSpent) {}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/ClientTotalSpent.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/ClientTopCategory.java ---
package com.buyone.orderservice.dto.response.analytics;

import java.math.BigDecimal;

public record ClientTopCategory(String category, BigDecimal totalSpent) {}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/response/analytics/ClientTopCategory.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/request/order/OrderSearchRequest.java ---
package com.buyone.orderservice.dto.request.order;

import jakarta.validation.constraints.Min;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class OrderSearchRequest {
    private String keyword;  // Product name/status search
    
    private String status;   // Optional filter: PENDING, etc.
    
    @Min(0)
    @Builder.Default
    private Integer page = 0;
    
    @Min(1)
    @Builder.Default
    private Integer size = 10;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/request/order/OrderSearchRequest.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/request/order/CreateOrderRequest.java ---
package com.buyone.orderservice.dto.request.order;

import com.buyone.orderservice.model.Address;
import jakarta.validation.Valid;
import lombok.Builder;
import lombok.Data;

@Data @Builder
public class CreateOrderRequest {
    @Valid
    private Address shippingAddress;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/request/order/CreateOrderRequest.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/request/cart/UpdateCartQuantityRequest.java ---
// UpdateCartQuantityRequest.java
package com.buyone.orderservice.dto.request.cart;

import jakarta.validation.constraints.Min;
import lombok.Data;

@Data
public class UpdateCartQuantityRequest {
    @Min(1) int quantity;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/request/cart/UpdateCartQuantityRequest.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/request/cart/AddCartItemRequest.java ---
// AddCartItemRequest.java
package com.buyone.orderservice.dto.request.cart;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.Builder;

@Data @Builder
public class AddCartItemRequest {
    @NotBlank String productId;
    @NotBlank String sellerId;
    @Min(1) int quantity;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/dto/request/cart/AddCartItemRequest.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/repository/OrderRepository.java ---
package com.buyone.orderservice.repository;

import com.buyone.orderservice.dto.response.analytics.*;
import com.buyone.orderservice.model.order.Order;
import com.buyone.orderservice.model.order.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.Aggregation;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;

import com.buyone.orderservice.dto.response.analytics.ClientTotalSpent;
import com.buyone.orderservice.dto.response.analytics.ClientMostBought;
import com.buyone.orderservice.dto.response.analytics.ClientTopCategory;
import com.buyone.orderservice.dto.response.analytics.SellerTotalRevenue;
import com.buyone.orderservice.dto.response.analytics.SellerBestProduct;
import com.buyone.orderservice.dto.response.analytics.SellerTotalUnits;


import java.util.List;
import java.util.Optional;

/**
 * OrderRepository with analytics aggregations for user/seller dashboards.
 * Uses MongoDB aggregation pipelines for efficient, indexed analytics queries.
 * Indexes recommended: {userId:1, status:1}, {status:1, "items.sellerId":1}
 */
public interface OrderRepository extends MongoRepository<Order, String> {
    
    List<Order> findByUserId(String userId);           // Buyer orders
    List<Order> findByUserIdAndStatus(String userId, OrderStatus status);
    Optional<Order> findByOrderNumber(String orderNumber);
    
    @Query(value = "{ 'userId': ?0, $or: [ " +
            "{ 'orderNumber': { $regex: ?1, $options: 'i' } }, " +
            "{ 'items.productName': { $regex: ?1, $options: 'i' } }, " +
            "{ 'status': ?2 } ] }",
            sort = "{ 'createdAt': -1 }")
    Page<Order> findBuyerOrdersSearch(String userId, String keyword, OrderStatus status, Pageable pageable);
    
    @Query("{ 'items.sellerId': ?0 }")
    Page<Order> findSellerOrders(String sellerId, Pageable pageable);
    // === CLIENT ANALYTICS ===
    @Aggregation(value = {
            "{ $match: { userId: ?0, status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $group: { _id: '$userId', totalSpent: { $sum: '$total' } } }"
    })
    List<ClientTotalSpent> getClientTotalSpent(String userId);
    
    @Aggregation(value = {
            "{ $match: { userId: ?0, status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $group: { _id: { productId: '$items.productId', name: '$items.productName' }, totalQty: { $sum: '$items.quantity' } } }",
            "{ $sort: { totalQty: -1 } }",
            "{ $limit: 5 }"
    })
    List<ClientMostBought> getClientMostBought(String userId);
    
    @Aggregation(value = {
            "{ $match: { userId: ?0, status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $group: { _id: '$items.category', totalSpent: { $sum: { $multiply: [ '$items.price', '$items.quantity' ] } } } }",
            "{ $sort: { totalSpent: -1 } }",
            "{ $limit: 5 }"
    })
    List<ClientTopCategory> getClientTopCategories(String userId);
    
    // === SELLER ANALYTICS ===
    @Aggregation(value = {
            "{ $match: { status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $match: { 'items.sellerId': ?0 } }",
            "{ $group: { _id: null, totalRevenue: { $sum: { $multiply: [ '$items.price', '$items.quantity' ] } } } }"
    })
    List<SellerTotalRevenue> getSellerTotalRevenue(String sellerId);
    
    @Aggregation(value = {
            "{ $match: { status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $match: { 'items.sellerId': ?0 } }",
            "{ $group: { _id: { productId: '$items.productId', name: '$items.productName' }, revenue: { $sum: { $multiply: [ '$items.price', '$items.quantity' ] } }, unitsSold: { $sum: '$items.quantity' } } }",
            "{ $sort: { revenue: -1 } }",
            "{ $limit: 5 }"
    })
    List<SellerBestProduct> getSellerBestProducts(String sellerId);
    
    @Aggregation(value = {
            "{ $match: { status: { $in: ['DELIVERED', 'CONFIRMED'] } } }",
            "{ $unwind: '$items' }",
            "{ $match: { 'items.sellerId': ?0 } }",
            "{ $group: { _id: null, totalUnits: { $sum: '$items.quantity' } } }"
    })
    List<SellerTotalUnits> getSellerTotalUnits(String sellerId);
    
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/repository/OrderRepository.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/repository/CartRepository.java ---
package com.buyone.orderservice.repository;

import com.buyone.orderservice.model.cart.Cart;
import org.springframework.data.mongodb.repository.MongoRepository;
import java.util.Optional;

public interface CartRepository extends MongoRepository<Cart, String> {
    Optional<Cart> findById(String userId);
    
    
    // MongoRepository ALREADY has these:
    // Cart save(Cart cart);           ‚Üê inherited
    // void deleteById(String userId); ‚Üê inherited
    
    // CUSTOM queries we'll need:
    // void deleteItem(String userId, String productId);  (later)
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/repository/CartRepository.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/config/SecurityConfig.java ---
package com.buyone.orderservice.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;

import org.springframework.security.web.SecurityFilterChain;


@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        logger.info("!!! Order-service SecurityConfig loaded - gateway headers trusted !!!");
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/actuator/**").permitAll()
                        .anyRequest().permitAll()  // Trust gateway headers
                );
        return http.build();
    }
}


-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/config/SecurityConfig.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/config/KafkaConfig.java ---
// src/main/java/com/buyone/productservice/config/KafkaConfig.java
package com.buyone.orderservice.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.beans.factory.annotation.Value;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {
    
    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;
    
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); // Change for prod!
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }
    
    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/config/KafkaConfig.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/controller/AnalyticsController.java ---
package com.buyone.orderservice.controller;

import com.buyone.orderservice.dto.response.ApiResponse;
import com.buyone.orderservice.dto.response.analytics.ClientAnalyticsResponse;
import com.buyone.orderservice.dto.response.analytics.SellerAnalyticsResponse;
import com.buyone.orderservice.service.ProfileAnalyticsService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/analytics")
@RequiredArgsConstructor
public class AnalyticsController {
    
    private final ProfileAnalyticsService profileAnalyticsService;
    
    @GetMapping("/client/{clientId}")
    public ResponseEntity<ApiResponse<ClientAnalyticsResponse>> getClientAnalytics(
            @PathVariable String clientId) {
        ClientAnalyticsResponse analytics = profileAnalyticsService.getClientAnalytics(clientId);
        return ResponseEntity.ok(ApiResponse.<ClientAnalyticsResponse>builder()
                .success(true)
                .message("Client analytics fetched successfully")
                .data(analytics)
                .build());
    }
    
    @GetMapping("/seller/{sellerId}")
    public ResponseEntity<ApiResponse<SellerAnalyticsResponse>> getSellerAnalytics(
            @PathVariable String sellerId) {
        SellerAnalyticsResponse analytics = profileAnalyticsService.getSellerAnalytics(sellerId);
        return ResponseEntity.ok(ApiResponse.<SellerAnalyticsResponse>builder()
                .success(true)
                .message("Seller analytics fetched successfully")
                .data(analytics)
                .build());
    }
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/controller/AnalyticsController.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/controller/OrderController.java ---
package com.buyone.orderservice.controller;

import com.buyone.orderservice.dto.request.order.CreateOrderRequest;
import com.buyone.orderservice.dto.request.order.OrderSearchRequest;
import com.buyone.orderservice.dto.response.ApiResponse;
import com.buyone.orderservice.dto.response.order.OrderResponse;
import com.buyone.orderservice.dto.response.order.OrderItemResponse;
import com.buyone.orderservice.model.order.Order;
import com.buyone.orderservice.model.order.OrderStatus;
import com.buyone.orderservice.service.OrderService;
import com.buyone.orderservice.exception.BadRequestException;
import io.swagger.v3.oas.annotations.Operation;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
@Slf4j
public class OrderController {
    
    private final OrderService orderService;
    
    @PostMapping("/checkout")
    @Operation(summary = "Create order from cart", description = "Pay on Delivery")
    public ResponseEntity<ApiResponse<OrderResponse>> createOrderFromCart(
            @Valid @RequestBody CreateOrderRequest req,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        log.info("Client {} checking out with address", userId);
        Order order = orderService.createOrderFromCart(userId, req.getShippingAddress());
        OrderResponse orderResp = mapToOrderResponse(order);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.<OrderResponse>builder()
                        .success(true)
                        .message("Order created successfully")
                        .data(orderResp)
                        .build());
    }
    
    @GetMapping("/buyer")
    @Operation(summary = "Get buyer orders")
    public ResponseEntity<ApiResponse<List<OrderResponse>>> getBuyerOrders(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        List<OrderResponse> orders = orderService.getBuyerOrders(userId)
                .stream()
                .map(this::mapToOrderResponse)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.<List<OrderResponse>>builder()
                .success(true)
                .message("Buyer orders fetched successfully")
                .data(orders)
                .build());
    }
    
    @GetMapping("/{orderNumber}")
    @Operation(summary = "Get order details")
    public ResponseEntity<ApiResponse<OrderResponse>> getOrder(@PathVariable String orderNumber) {
        OrderResponse order = orderService.getOrder(orderNumber)
                .map(this::mapToOrderResponse)
                .orElseThrow(() -> new BadRequestException("Order not found: " + orderNumber));
        return ResponseEntity.ok(ApiResponse.<OrderResponse>builder()
                .success(true)
                .message("Order details fetched successfully")
                .data(order)
                .build());
    }
    
    @PutMapping("/{orderNumber}/status")
    @Operation(summary = "Update order status", description = "Seller: PENDING‚ÜíCONFIRMED‚ÜíSHIPPED‚ÜíDELIVERED")
    public ResponseEntity<ApiResponse<OrderResponse>> updateStatus(
            @PathVariable String orderNumber,
            @RequestParam OrderStatus status,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "SELLER");
        log.info("Seller {} updating order {} to {}", sellerId, orderNumber, status);
        OrderResponse updated = orderService.updateStatus(orderNumber, sellerId, status)
                .map(this::mapToOrderResponse)
                .orElseThrow(() -> new BadRequestException("Order not found or update failed: " + orderNumber));
        return ResponseEntity.ok(ApiResponse.<OrderResponse>builder()
                .success(true)
                .message("Order status updated successfully")
                .data(updated)
                .build());
    }
    
    @PostMapping("/{orderNumber}/cancel")
    @Operation(summary = "Cancel PENDING order")
    public ResponseEntity<ApiResponse<Void>> cancelOrder(
            @PathVariable String orderNumber,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        orderService.cancelOrder(orderNumber, userId);
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("Order cancelled successfully")
                .build());
    }
    
    @PostMapping("/{orderNumber}/redo")
    @Operation(summary = "Redo CANCELLED order")
    public ResponseEntity<ApiResponse<OrderResponse>> redoOrder(
            @PathVariable String orderNumber,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        OrderResponse newOrder = orderService.redoOrder(orderNumber, userId)
                .map(this::mapToOrderResponse)
                .orElseThrow(() -> new BadRequestException("Order not found: " + orderNumber));
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.<OrderResponse>builder()
                        .success(true)
                        .message("Order recreated successfully")
                        .data(newOrder)
                        .build());
    }
    
    @GetMapping("/buyer/search")
    @Operation(summary = "Search buyer orders")
    public ResponseEntity<ApiResponse<Page<OrderResponse>>> searchMyOrders(
            @Valid @ModelAttribute OrderSearchRequest req,
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "CLIENT");
        Page<OrderResponse> orders = orderService.searchBuyerOrders(userId, req)
                .map(this::mapToOrderResponse);
        return ResponseEntity.ok(ApiResponse.<Page<OrderResponse>>builder()
                .success(true)
                .message("Buyer orders search completed")
                .data(orders)
                .build());
    }
    
    @GetMapping("/seller")
    @Operation(summary = "Get seller orders", description = "Paginated dashboard")
    public ResponseEntity<ApiResponse<Page<OrderResponse>>> getSellerOrders(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, "SELLER");
        Pageable pageable = PageRequest.of(page, size);
        Page<OrderResponse> orders = orderService.getSellerOrders(sellerId, pageable)
                .map(this::mapToOrderResponse);
        return ResponseEntity.ok(ApiResponse.<Page<OrderResponse>>builder()
                .success(true)
                .message("Seller orders fetched successfully")
                .data(orders)
                .build());
    }
    
    private void validateRole(String role, String requiredRole) {
        if (!requiredRole.equals(role)) {
            throw new BadRequestException("Required role: " + requiredRole + ", got: " + role);
        }
    }
    
    private OrderResponse mapToOrderResponse(Order order) {
        List<OrderItemResponse> items = order.getItems().stream()
                .map(item -> OrderItemResponse.builder()
                        .productName(item.getProductName())
                        .sellerId(item.getSellerId())
                        .price(item.getPrice())
                        .quantity(item.getQuantity())
                        .build())
                .collect(Collectors.toList());
        
        return OrderResponse.builder()
                .orderNumber(order.getOrderNumber())
                .status(order.getStatus())
                .total(order.getTotal())
                .subtotal(order.getSubtotal())
                .tax(order.getTax())
                .createdAt(order.getCreatedAt())
                .shippingAddress(order.getShippingAddress())
                .items(items)
                .build();
    }
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/controller/OrderController.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/controller/CartController.java ---
package com.buyone.orderservice.controller;

import com.buyone.orderservice.dto.response.ApiResponse;
import com.buyone.orderservice.model.cart.Cart;
import com.buyone.orderservice.model.cart.CartItem;
import com.buyone.orderservice.service.CartService;
import com.buyone.orderservice.exception.BadRequestException;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/api/cart")
@RequiredArgsConstructor
@Slf4j
public class CartController {
    
    private static final String CLIENT_ROLE = "CLIENT";
    private final CartService cartService;
    
    @PostMapping("/items")
    @Operation(summary = "Add item to cart", description = "Merge if same product+seller")
    public ResponseEntity<ApiResponse<Cart>> addItem(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role,
            @Valid @RequestBody CartItem item) {
        validateRole(role, CLIENT_ROLE);
        log.debug("Adding item to cart for user: {}", userId);
        Cart cart = cartService.addItem(userId, item);
        return ResponseEntity.ok(ApiResponse.<Cart>builder()
                .success(true)
                .message("Item added to cart successfully")
                .data(cart)
                .build());
    }
    
    @GetMapping
    @Operation(summary = "Get current cart")
    public ResponseEntity<ApiResponse<Optional<Cart>>> getCart(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, CLIENT_ROLE);
        Optional<Cart> cartOpt = cartService.getCart(userId);
        if (cartOpt.isEmpty()) {
            return ResponseEntity.ok(ApiResponse.<Optional<Cart>>builder()
                    .success(true)
                    .message("Cart is empty")
                    .data(Optional.empty())
                    .build());
        }
        return ResponseEntity.ok(ApiResponse.<Optional<Cart>>builder()
                .success(true)
                .message("Cart fetched successfully")
                .data(cartOpt)
                .build());
    }
    
    @PutMapping("/items/{productId}/quantity/{quantity}")
    @Operation(summary = "Update item quantity")
    public ResponseEntity<ApiResponse<Cart>> updateQuantity(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role,
            @PathVariable String productId,
            @PathVariable int quantity) {
        validateRole(role, CLIENT_ROLE);
        Cart cart = cartService.updateQuantity(userId, productId, quantity);
        return ResponseEntity.ok(ApiResponse.<Cart>builder()
                .success(true)
                .message("Item quantity updated successfully")
                .data(cart)
                .build());
    }
    
    @DeleteMapping("/items/{productId}")
    @Operation(summary = "Remove item from cart")
    public ResponseEntity<ApiResponse<Void>> removeItem(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role,
            @PathVariable String productId) {
        validateRole(role, CLIENT_ROLE);
        cartService.removeItem(userId, productId);
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("Item removed from cart successfully")
                .build());
    }
    
    @DeleteMapping
    @Operation(summary = "Clear entire cart")
    public ResponseEntity<ApiResponse<Void>> clearCart(
            @RequestHeader("X-USER-ID") String userId,
            @RequestHeader("X-USER-ROLE") String role) {
        validateRole(role, CLIENT_ROLE);
        cartService.clearCart(userId);
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("Cart cleared successfully")
                .build());
    }
    
    private void validateRole(String role, String requiredRole) {
        if (!requiredRole.equals(role)) {
            throw new BadRequestException("Required role: " + requiredRole + ", got: " + role);
        }
    }
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/controller/CartController.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/OrderServiceApplication.java ---
package com.buyone.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableFeignClients
@EnableDiscoveryClient
public class OrderServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(OrderServiceApplication.class, args);
	}

}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/OrderServiceApplication.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/order/Order.java ---
package com.buyone.orderservice.model.order;

import com.buyone.orderservice.model.Address;
import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import static com.buyone.orderservice.model.order.OrderStatus.PENDING;
import static com.buyone.orderservice.model.order.PaymentMethod.PAY_ON_DELIVERY;

@Document(collection = "orders")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    @Id
    private String id;
    
    @Indexed
    private String userId;       // "Buyer" - CLIENT Role Only
    
    @Indexed(unique = true)
    private String orderNumber;  // Unique: "ORD-" + UUID
    
    @Builder.Default
    private List<OrderItem> items = new ArrayList<>();
    
    @Builder.Default
    private OrderStatus status = PENDING;
    // "PENDING", "CONFIRMED", "SHIPPED", "DELIVERED", "CANCELLED"
    
    @Builder.Default
    private PaymentMethod paymentMethod = PAY_ON_DELIVERY;
    
    private Address shippingAddress;  // Inline or ref
    
    private BigDecimal subtotal;
    private BigDecimal tax;
    private BigDecimal total;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/order/Order.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/order/OrderItem.java ---
package com.buyone.orderservice.model.order;

import lombok.*;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {
    private String productId;
    private String productName;
    private String sellerId;    // For seller dashboards/revenue "SELLER" from user DB
    private BigDecimal price;
    private int quantity;
    private String imageUrl;    // First image from Product.images
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/order/OrderItem.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/order/OrderStatus.java ---
package com.buyone.orderservice.model.order;

public enum OrderStatus {
    PENDING,      // Just created
    CONFIRMED,    // Payment accepted
    SHIPPED,      // Seller shipped
    DELIVERED,    // Arrived
    CANCELLED     // Buyer/seller cancelled
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/order/OrderStatus.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/order/PaymentMethod.java ---
package com.buyone.orderservice.model.order;

public enum PaymentMethod {
    PAY_ON_DELIVERY,
    CARD,
    PAYPAL,
}-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/order/PaymentMethod.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/Product.java ---
package com.buyone.orderservice.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.math.BigDecimal;


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder

@Document(collection = "products")
public class Product {
    @Id
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer quantity;
    private String userId;
    private String categoryId;
    private java.util.List<String> images;
}-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/Product.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/Address.java ---
package com.buyone.orderservice.model;

import lombok.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Address {
    @NotBlank(message = "Street is required")
    private String street;
    
    @NotBlank(message = "City is required")
    private String city;
    private String state;
    
    @NotBlank(message = "ZIP/Postal code is required")
    @Pattern(regexp = "^[0-9]{5}$", message = "ZIP must be 5 digits")
    private String zipCode;
    
    @NotBlank(message = "Country is required")
    private String country;
    
    @Pattern(regexp = "^[+]?[0-9]{10,15}$", message = "Invalid phone format")
    private String phone;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/Address.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/cart/CartItem.java ---
package com.buyone.orderservice.model.cart;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.*;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CartItem {
    @NotBlank
    private String productId;
    
    @NotBlank
    private String sellerId;
    
    @NotBlank
    private String productName;
    
    private BigDecimal price;
    
    @Min(1)
    private int quantity = 1;
    
    private String imageUrl;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/cart/CartItem.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/cart/Cart.java ---
package com.buyone.orderservice.model.cart;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.*;

@Document(collection = "carts")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Setter
public class Cart {
    @Id
    @Indexed(unique = true)
    private String id;
    private String userId;
    
    @Builder.Default
    private List<CartItem> items = new ArrayList<>();
    
    private BigDecimal subtotal;
    private BigDecimal tax;
    private BigDecimal total;
    private LocalDateTime updatedAt;
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/model/cart/Cart.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/impl/ProfileAnalyticsServiceImpl.java ---
package com.buyone.orderservice.service.impl;

import com.buyone.orderservice.dto.response.analytics.*;
import com.buyone.orderservice.repository.OrderRepository;
import com.buyone.orderservice.service.ProfileAnalyticsService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProfileAnalyticsServiceImpl implements ProfileAnalyticsService {
    
    private final OrderRepository orderRepository;
    
    @Override
    public ClientAnalyticsResponse getClientAnalytics(String userId) {
        // ‚úÖ Use your new repo methods (no MongoTemplate needed!)
        List<ClientTotalSpent> totalSpentList = orderRepository.getClientTotalSpent(userId);
        List<ClientMostBought> mostBought = orderRepository.getClientMostBought(userId);
        List<ClientTopCategory> topCategories = orderRepository.getClientTopCategories(userId);
        
        BigDecimal totalSpent = totalSpentList.isEmpty()
                ? BigDecimal.ZERO
                : totalSpentList.get(0).totalSpent();
        
        log.info("Client {} analytics: ${} spent, {} top products",
                userId, totalSpent, mostBought.size());
        
        return new ClientAnalyticsResponse(totalSpent, mostBought, topCategories);
    }
    
    @Override
    public SellerAnalyticsResponse getSellerAnalytics(String sellerId) {
        List<SellerTotalRevenue> revenueList = orderRepository.getSellerTotalRevenue(sellerId);
        List<SellerBestProduct> bestProducts = orderRepository.getSellerBestProducts(sellerId);
        List<SellerTotalUnits> unitsList = orderRepository.getSellerTotalUnits(sellerId);
        
        BigDecimal totalRevenue = revenueList.isEmpty()
                ? BigDecimal.ZERO
                : revenueList.get(0).totalRevenue();
        
        Integer totalUnits = unitsList.isEmpty()
                ? 0
                : unitsList.get(0).totalUnits();
        
        log.info("Seller {} analytics: ${} revenue, {} units, {} top products",
                sellerId, totalRevenue, totalUnits, bestProducts.size());
        
        return new SellerAnalyticsResponse(totalRevenue, bestProducts, totalUnits);
    }
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/impl/ProfileAnalyticsServiceImpl.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/impl/OrderServiceImpl.java ---
package com.buyone.orderservice.service.impl;

import com.buyone.orderservice.client.ProductClient;
import com.buyone.orderservice.dto.request.order.OrderSearchRequest;
import com.buyone.orderservice.exception.BadRequestException;
import com.buyone.orderservice.exception.ResourceNotFoundException;
import com.buyone.orderservice.model.*;
import com.buyone.orderservice.model.cart.Cart;
import com.buyone.orderservice.model.cart.CartItem;
import com.buyone.orderservice.model.order.Order;
import com.buyone.orderservice.model.order.OrderItem;
import com.buyone.orderservice.model.order.OrderStatus;
import com.buyone.orderservice.model.order.PaymentMethod;
import com.buyone.orderservice.repository.OrderRepository;
import com.buyone.orderservice.service.CartService;
import com.buyone.orderservice.service.OrderService;
import com.buyone.orderservice.dto.response.ProductResponse;
import com.buyone.orderservice.dto.response.ApiResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * OrderService implementation with re-fetch snapshot strategy for production accuracy.
 * Creates immutable order records with fresh product data at checkout time.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class OrderServiceImpl implements OrderService {
    
    private final OrderRepository orderRepository;
    private final CartService cartService;
    private final ProductClient productClient;  // Re-fetches live product data
    
    /**
     * Creates order from cart with FRESH product snapshots (price/name/seller).
     * Validates cart ‚Üí re-fetches products ‚Üí calculates totals ‚Üí saves ‚Üí clears cart.
     */
    @Override
    public Order createOrderFromCart(String userId, Address shippingAddress) {
        var cartItems = getValidatedCartItems(userId);
        
        // Re-fetch LIVE products ‚Üí Fresh, legally-accurate snapshots
        List<OrderItem> orderItems = cartItems.stream()
                .map(this::fetchFreshProductSnapshot)
                .toList();
        
        // Precise money calculations
        BigDecimal subtotal = calculateSubtotal(orderItems);
        BigDecimal tax = calculateTax(subtotal);
        
        // Build order
        String orderNumber = generateOrderNumber();
        Order order = Order.builder()
                .userId(userId)
                .orderNumber(orderNumber)
                .items(orderItems)
                .status(OrderStatus.PENDING)
                .paymentMethod(PaymentMethod.PAY_ON_DELIVERY)
                .shippingAddress(shippingAddress)
                .subtotal(subtotal)
                .tax(tax)
                .total(subtotal.add(tax))
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();
        
        Order saved = orderRepository.save(order);
        
        // Post-checkout actions
        cartService.clearCart(userId);
        reserveInventoryAsync(orderItems, orderNumber);
        
        log.info("Order {} created for {} (subtotal: {})", orderNumber, userId, subtotal);
        return saved;
    }
    
    /**
     * Gets cart items with validation - quantities only (don't trust stale cart data).
     */
    private List<CartItem> getValidatedCartItems(String userId) {
        var cartOpt = cartService.getCart(userId);
        var cartItems = cartOpt.map(Cart::getItems)
                .orElseThrow(() -> new ResourceNotFoundException("Cart not found: " + userId));
        if (cartItems.isEmpty()) throw new IllegalStateException("Empty cart");
        return cartItems;
    }
    
    /**
     * Fetches LIVE product data ‚Üí Creates immutable snapshot for order.
     * Guarantees accuracy even if seller changed price/name since cart add.
     */
    private OrderItem fetchFreshProductSnapshot(CartItem cartItem) {
        ApiResponse<ProductResponse> response = productClient.getById(cartItem.getProductId());
        
        if (!response.isSuccess() || response.getData() == null) {
            log.warn("Product not found for order snapshot: {}", cartItem.getProductId());
            throw new ResourceNotFoundException("Product not found: " + cartItem.getProductId());
        }
        
        ProductResponse product = response.getData();
        
        return OrderItem.builder()
                .productId(product.getId())
                .productName(product.getName())
                .sellerId(product.getUserId())  // Maps userId ‚Üí sellerId
                .price(product.getPrice())
                .quantity(cartItem.getQuantity())
                .imageUrl(safeFirstImage(product.getImages()))
                .build();
    }

    
    /**
     * Safely extracts first image URL - null-safe.
     */
    private String safeFirstImage(List<String> images) {
        return images != null && !images.isEmpty() ? images.get(0) : null;
    }
    
    /**
     * Generates unique order number: ORD-ABC12345
     */
    private String generateOrderNumber() {
        return "ORD-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }
    
    /**
     * Calculates subtotal: Œ£(price √ó quantity) exactly.
     */
    private BigDecimal calculateSubtotal(List<OrderItem> items) {
        return items.stream()
                .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    /**
     * 10% tax, rounded to 2 decimals (business rule).
     */
    private BigDecimal calculateTax(BigDecimal subtotal) {
        return subtotal.multiply(BigDecimal.valueOf(0.1)).setScale(2, RoundingMode.HALF_UP);
    }
    
    /**
     * Queues inventory reservation (TODO: @Async + RabbitMQ).
     */
    private void reserveInventoryAsync(List<OrderItem> items, String orderNumber) {
        log.debug("Inventory reservation queued for order: {}", orderNumber);
        // TODO: productClient.reserveStock(items, orderNumber);
    }
    
    // ========== EXISTING METHODS (PERFECT - MINOR ENUM FIXES) ==========
    
    @Override
    public List<Order> getBuyerOrders(String userId) {
        return orderRepository.findByUserId(userId);
    }
    
    @Override
    public Optional<Order> getOrder(String orderNumber) {
        return orderRepository.findByOrderNumber(orderNumber);
    }
    
    /**
     * Seller/admin updates status (CONFIRMED‚ÜíSHIPPED‚ÜíDELIVERED).
     */
    @Override
    public Optional<Order> updateStatus(String orderNumber, String sellerId, OrderStatus status) {
        Order order = getOrder(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found: " + orderNumber));
        
        // CRITICAL CHECK
        // Seller owns all items
        boolean ownsAllItems = order.getItems().stream()
                .allMatch(item -> sellerId.equals(item.getSellerId()));
        if (!ownsAllItems) {
            throw new BadRequestException("Seller not authorized for this order");
        }
        
        order.setStatus(status);
        order.setUpdatedAt(LocalDateTime.now());
        return Optional.of(orderRepository.save(order));
    }
    
    /**
     * Buyer cancels PENDING order ‚Üí CANCELLED.
     */
    @Override
    public void cancelOrder(String orderNumber, String userId) {
        Order order = getOrder(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found: " + orderNumber));
        // ownership check
        if (!userId.equals(order.getUserId())) {
            throw new BadRequestException("Not your order");
        }
        
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new IllegalStateException("Only PENDING orders can be cancelled");
        }
        order.setStatus(OrderStatus.CANCELLED);
        order.setUpdatedAt(LocalDateTime.now());
        orderRepository.save(order);
    }
    
    /**
     * Buyer redoes CANCELLED order ‚Üí clones to new cart ‚Üí new order.
     */
    @Override
    public Optional<Order> redoOrder(String orderNumber, String userId) {
        return getOrder(orderNumber)  // Optional chain
                .filter(order -> userId.equals(order.getUserId()))  // Ownership
                .filter(order -> order.getStatus() == OrderStatus.CANCELLED)
                .map(oldOrder -> {
                    List<CartItem> newItems = oldOrder.getItems().stream()
                            .map(this::orderItemToCartItem)
                            .collect(Collectors.toList());
                    Cart newCart = Cart.builder()
                            .userId(userId)
                            .items(newItems)
                            .build();
                    cartService.saveCart(newCart);
                    return createOrderFromCart(userId, null);  // refresh prices if changed
                });
    }
    
    @Override
    public Page<Order> searchBuyerOrders(String userId, OrderSearchRequest req) {
        OrderStatus status = req.getStatus() != null ? OrderStatus.valueOf(req.getStatus()) : null;
        Pageable pageable = PageRequest.of(req.getPage(), req.getSize());
        return orderRepository.findBuyerOrdersSearch(userId, req.getKeyword(), status, pageable);
    }
    
    @Override
    public Page<Order> getSellerOrders(String sellerId, Pageable pageable) {
        return orderRepository.findSellerOrders(sellerId, pageable);
    }
    
    /**
     * Converts OrderItem ‚Üí CartItem for redo (double back-convert).
     */
    private CartItem orderItemToCartItem(OrderItem item) {
        return CartItem.builder()
                .productId(item.getProductId())
                .productName(item.getProductName())
                .sellerId(item.getSellerId())
                .price(item.getPrice())
                .quantity(item.getQuantity())
                .imageUrl(item.getImageUrl())
                .build();
    }
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/impl/OrderServiceImpl.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/impl/CartServiceImpl.java ---
package com.buyone.orderservice.service.impl;

import com.buyone.orderservice.client.ProductClient;
import com.buyone.orderservice.exception.BadRequestException;
import com.buyone.orderservice.model.Product;
import com.buyone.orderservice.model.cart.Cart;
import com.buyone.orderservice.model.cart.CartItem;
import com.buyone.orderservice.dto.response.ProductResponse;
import com.buyone.orderservice.dto.response.ApiResponse;
import com.buyone.orderservice.repository.CartRepository;
import com.buyone.orderservice.service.CartService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;
import org.springframework.beans.factory.annotation.Value;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
@Validated  // For method-level validation
public class CartServiceImpl implements CartService {
    
    private final CartRepository cartRepository;
    private final ProductClient productClient;  //  Fixed: no @Autowired
    
    @Value("${app.cart.tax-rate:0.1}")  //  Configurable
    private double taxRate;
    
    @Override
    @Transactional  // Consistency guarantee
    public Cart addItem(String userId, CartItem item) {
        validateCartItem(item);
        Cart cart = getOrCreateCart(userId);
        
        // Merge if exists (multi-seller support)
        Optional<CartItem> existing = cart.getItems().stream()
                .filter(ci -> ci.getProductId().equals(item.getProductId())
                        && ci.getSellerId().equals(item.getSellerId()))
                .findFirst();
        
        if (existing.isPresent()) {
            existing.get().setQuantity(existing.get().getQuantity() + item.getQuantity());
        } else {
            // Production integration - Full ApiResponse handling
            ApiResponse<ProductResponse> response = productClient.getById(item.getProductId());
            
            if (!response.isSuccess() || response.getData() == null) {
                log.warn("Product not found: {}", item.getProductId());
                throw new BadRequestException("Product not found: " + item.getProductId());
            }
            
            ProductResponse product = response.getData();
            
            // Debug logs (keep for now)
            log.info("Product: {} quantity={}, request qty={}",
                    product.getId(),
                    product.getQuantity(),
                    item.getQuantity());
            
            int availableStock = Optional.ofNullable(product.getQuantity()).orElse(0);
            log.info("Available: {}, requested: {}", availableStock, item.getQuantity());
            
            if (availableStock < item.getQuantity()) {
                throw new BadRequestException("Insufficient stock: " + item.getQuantity() +
                        " requested, " + availableStock + " available");
            }
            
            // Populate cart item snapshot
            item.setProductName(product.getName());
            item.setPrice(product.getPrice());
            item.setImageUrl(product.getImages() != null && !product.getImages().isEmpty()
                    ? product.getImages().get(0) : null);
            
            cart.getItems().add(item);
        }
        return recalculateTotals(cart);
    }
    
    @Override
    public Optional<Cart> getCart(String userId) {
        return cartRepository.findById(userId);
    }
    
    @Override
    @Transactional
    public Cart updateQuantity(String userId, String productId,
                               int quantity) {
        Cart cart = getOrCreateCart(userId);
        boolean updated = cart.getItems().stream()
                .filter(ci -> ci.getProductId().equals(productId))
                .findFirst()
                .map(ci -> {
                    ci.setQuantity(quantity);
                    return true;
                }).orElse(false);
        
        if (!updated) {
            throw new BadRequestException("Product not found in cart: " + productId);
        }
        
        cart.getItems().removeIf(ci -> ci.getQuantity() <= 0);
        return recalculateTotals(cart);
    }
    
    @Override
    @Transactional
    public Cart removeItem(String userId, String productId) {
        Cart cart = getOrCreateCart(userId);
        boolean removed = cart.getItems().removeIf(ci -> ci.getProductId().equals(productId));
        if (!removed) {
            log.warn("Item not found in cart: user={}, product={}", userId, productId);
        }
        return recalculateTotals(cart);
    }
    
    @Override
    @Transactional
    public Cart clearCart(String userId) {
        return cartRepository.save(Cart.builder()
                .id(userId)
                .userId(userId)
                .items(new ArrayList<>())
                .subtotal(BigDecimal.ZERO)
                .tax(BigDecimal.ZERO)
                .total(BigDecimal.ZERO)
                .updatedAt(LocalDateTime.now())
                .build());
    }
    
    private Cart getOrCreateCart(String userId) {
        return cartRepository.findById(userId)
                .orElse(Cart.builder()
                        .id(userId)
                        .userId(userId)
                        .items(new ArrayList<>())
                        .build());
    }
    
    private Cart recalculateTotals(Cart cart) {
        BigDecimal subtotal = cart.getItems().stream()
                .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal tax = subtotal.multiply(BigDecimal.valueOf(taxRate))
                .setScale(2, RoundingMode.HALF_UP);
        BigDecimal total = subtotal.add(tax);
        
        cart.setSubtotal(subtotal);
        cart.setTax(tax);
        cart.setTotal(total);
        cart.setUpdatedAt(LocalDateTime.now());
        
        return cartRepository.save(cart);
    }
    
    private void validateCartItem(CartItem item) {
        if (item.getQuantity() <= 0) {
            throw new BadRequestException("Quantity must be positive");
        }
        if (item.getProductId() == null || item.getProductId().trim().isEmpty()) {
            throw new BadRequestException("Product ID is required");
        }
        if (item.getSellerId() == null || item.getSellerId().trim().isEmpty()) {
            throw new BadRequestException("Seller ID is required");
        }
    }
    @Override
    @Transactional
    public void saveCart(Cart cart) {
        cartRepository.save(cart);
    }
    
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/impl/CartServiceImpl.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/ProfileAnalyticsService.java ---
package com.buyone.orderservice.service;

import com.buyone.orderservice.dto.response.analytics.ClientAnalyticsResponse;
import com.buyone.orderservice.dto.response.analytics.SellerAnalyticsResponse;

public interface ProfileAnalyticsService {
    ClientAnalyticsResponse getClientAnalytics(String userId);
    SellerAnalyticsResponse getSellerAnalytics(String sellerId);
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/ProfileAnalyticsService.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/CartService.java ---
package com.buyone.orderservice.service;

import com.buyone.orderservice.model.cart.Cart;
import com.buyone.orderservice.model.cart.CartItem;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Min;
import java.util.Optional;

public interface CartService {
    Cart addItem(@NotBlank String userId, CartItem item);
    Optional<Cart> getCart(String userId);
    Cart updateQuantity(@NotBlank String userId, @NotBlank String productId, @Min(1) int quantity);
    Cart removeItem(@NotBlank String userId, String productId);
    Cart clearCart(@NotBlank String userId);
    void saveCart(Cart cart);
    
}-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/CartService.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/OrderService.java ---
package com.buyone.orderservice.service;

import com.buyone.orderservice.dto.request.order.OrderSearchRequest;
import com.buyone.orderservice.model.Address;
import com.buyone.orderservice.model.order.Order;
import com.buyone.orderservice.model.order.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;

public interface OrderService {
    Order createOrderFromCart(String userId, Address shippingAddress);
    
    List<Order> getBuyerOrders(String userId);
    
    Optional<Order> getOrder(String orderNumber);
    
    Optional<Order> updateStatus(String orderNumber, String sellerId, OrderStatus status);
    
    Page<Order> searchBuyerOrders(String userId, OrderSearchRequest req);
    
    Page<Order> getSellerOrders(String sellerId, Pageable pageable);
    
    void cancelOrder(String orderNumber, String userId);  // Only PENDING ‚Üí CANCELLED
    
    Optional<Order> redoOrder(String orderNumber, String userId);   // CANCELLED ‚Üí new cart ‚Üí new order
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/service/OrderService.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/ForbiddenException.java ---
package com.buyone.orderservice.exception;

public class ForbiddenException extends RuntimeException {
    
    public ForbiddenException() {
        super();
    }
    
    public ForbiddenException(String message) {
        super(message);
    }
    
    public ForbiddenException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ForbiddenException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/ForbiddenException.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/ResourceNotFoundException.java ---
package com.buyone.orderservice.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException() {
        super();
    }
    
    public ResourceNotFoundException(String message) {
        super(message);
    }
    
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ResourceNotFoundException(Throwable cause) {
        super(cause);
    }
}-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/ResourceNotFoundException.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/ConflictException.java ---
package com.buyone.orderservice.exception;

public class ConflictException extends RuntimeException {
    
    public ConflictException() {
        super();
    }
    
    public ConflictException(String message) {
        super(message);
    }
    
    public ConflictException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ConflictException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/ConflictException.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/GlobalExceptionHandler.java ---
package com.buyone.orderservice.exception;

import com.buyone.orderservice.dto.response.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import lombok.extern.slf4j.Slf4j;

import jakarta.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.util.stream.Collectors;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // Helper for building consistent error responses
    private ResponseEntity<ErrorResponse> buildError(HttpStatus status, String message, String path) {
        ErrorResponse error = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(status.value())
                .error(status.getReasonPhrase())
                .message(message)
                .path(path)
                .build();
        return new ResponseEntity<>(error, status);
    }
    
    // 400: Bean validation (@Valid) errors
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex, HttpServletRequest request) {
        // Collects all field validation errors into a single string
        String message = ex.getBindingResult().getFieldErrors().stream()
                .map(err -> err.getField() + ": " + err.getDefaultMessage())
                .collect(Collectors.joining(", "));
        return buildError(HttpStatus.BAD_REQUEST, message, request.getRequestURI());
    }
    
    // 400: Custom bad request
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequest(BadRequestException ex, HttpServletRequest request) {
        return buildError(HttpStatus.BAD_REQUEST, ex.getMessage(), request.getRequestURI());
    }
    
    // 403: Forbidden (custom app-level)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbidden(ForbiddenException ex, HttpServletRequest request) {
        return buildError(HttpStatus.FORBIDDEN, ex.getMessage(), request.getRequestURI());
    }
    
    // 403: Spring Security's access denied
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        return buildError(HttpStatus.FORBIDDEN, "Access Denied: " + ex.getMessage(), request.getRequestURI());
    }
    
    // 405: HTTP Method not allowed
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowed(HttpRequestMethodNotSupportedException ex, HttpServletRequest request) {
        return buildError(HttpStatus.METHOD_NOT_ALLOWED, "Method Not Allowed: " + ex.getMessage(), request.getRequestURI());
    }
    
    // 409: Conflict (e.g., duplicate product name)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflict(ConflictException ex, HttpServletRequest request) {
        return buildError(HttpStatus.CONFLICT, ex.getMessage(), request.getRequestURI());
    }
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgument(IllegalArgumentException ex, HttpServletRequest request) {
        return buildError(HttpStatus.BAD_REQUEST, ex.getMessage(), request.getRequestURI());
    }
    
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ErrorResponse> handleIllegalState(IllegalStateException ex, HttpServletRequest request) {
        return buildError(HttpStatus.UNPROCESSABLE_ENTITY, ex.getMessage(), request.getRequestURI());
    }
    // 500: Fallback for unhandled exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex, HttpServletRequest request) {
        log.error("Unhandled [{}]: {}", request.getRequestURI(), ex.getMessage(), ex);
        return buildError(HttpStatus.INTERNAL_SERVER_ERROR, "Internal server error", request.getRequestURI());
    }

}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/GlobalExceptionHandler.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/BadRequestException.java ---
package com.buyone.orderservice.exception;

public class BadRequestException extends RuntimeException {
    public BadRequestException() {
        super();
    }
    
    public BadRequestException(String message) {
        super(message);
    }
    
    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public BadRequestException(Throwable cause) {
        super(cause);
    }
}-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/exception/BadRequestException.java ---

--- FILE: backend/order-service/src/main/java/com/buyone/orderservice/client/ProductClient.java ---
package com.buyone.orderservice.client;

import com.buyone.orderservice.dto.response.ProductResponse;
import com.buyone.orderservice.dto.response.ApiResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "product-service")
public interface ProductClient {
    @GetMapping("/products/{id}")
    ApiResponse<ProductResponse> getById(@PathVariable("id") String id);
}
-e 
--- END FILE: backend/order-service/src/main/java/com/buyone/orderservice/client/ProductClient.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/repository/ProductRepository.java ---
package com.buyone.productservice.repository;

import com.buyone.productservice.model.Product;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.List;

public interface ProductRepository extends MongoRepository<Product, String> {
    List<Product> findByUserId(String userId);
    void deleteByUserId(String userId);
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/repository/ProductRepository.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/repository/CategoryRepository.java ---
package com.buyone.productservice.repository;

import com.buyone.productservice.model.Category;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.List;

public interface CategoryRepository extends MongoRepository<Category, String> {
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/repository/CategoryRepository.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/response/CategoryResponse.java ---
package com.buyone.productservice.response;

public record CategoryResponse(
        String id,
        String slug,
        String name,
        String icon,
        String description
) {}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/response/CategoryResponse.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/response/ApiResponse.java ---
package com.buyone.productservice.response;

import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/response/ApiResponse.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/response/ProductResponse.java ---
package com.buyone.productservice.response;

import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Builder;

import java.math.BigDecimal;


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductResponse {
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer quantity;
    private String userId;
    private String categoryId;
    private java.util.List<String> images;
    
    // private String mediaId;
    // Optional:
    // private Instant createdAt;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/response/ProductResponse.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/response/ErrorResponse.java ---
package com.buyone.productservice.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Builder;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@Builder
public class ErrorResponse {
    private int status;
    private String error;
    private String message;
    private String path;
    private LocalDateTime timestamp;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/response/ErrorResponse.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/config/SecurityConfig.java ---
package com.buyone.productservice.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {
    private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        logger.info("!!! SecurityConfig loaded, CSRF disabled !!!");
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth.anyRequest().permitAll());
        return http.build();
    }
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/config/SecurityConfig.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/config/KafkaConfig.java ---
// src/main/java/com/buyone/productservice/config/KafkaConfig.java
package com.buyone.productservice.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.beans.factory.annotation.Value;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {
    
    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;
    
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); // Change for prod!
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }
    
    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/config/KafkaConfig.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/controller/ProductController.java ---
package com.buyone.productservice.controller;

import com.buyone.productservice.request.CreateProductRequest;
import com.buyone.productservice.request.UpdateProductRequest;
import com.buyone.productservice.response.ProductResponse;
import com.buyone.productservice.response.ApiResponse;
import com.buyone.productservice.exception.ForbiddenException;
import com.buyone.productservice.service.ProductService;
import lombok.RequiredArgsConstructor;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

import jakarta.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/products")
@Validated
@RequiredArgsConstructor
public class ProductController {
    
    private final ProductService productService;
    
    // GET /products (public) or GET /products?sellerId=... (public)
    @GetMapping
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getProducts(
            @RequestParam(required = false) String sellerId) {

        List<ProductResponse> products;

        if (sellerId != null) {
            products = productService.getProductsBySeller(sellerId);
        } else {
            products = productService.getAllProducts();
        }

        return ResponseEntity.ok(okResponse("Products fetched successfully", products));
    }

    
    // GET /products/{id} (public)
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductResponse>> getProductById(@PathVariable String id) {
        ProductResponse product = productService.getProductById(id);
        return ResponseEntity.ok(okResponse("Product fetched successfully", product));
    }
    
    // POST /products (seller only)
    @PostMapping
    public ResponseEntity<ApiResponse<ProductResponse>> createProduct(
            @Valid @RequestBody CreateProductRequest request,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role
    ) {
        if (!"SELLER".equals(role)) {
            throw new ForbiddenException("Only sellers can create products.");
        }
        
        ProductResponse product = productService.createProduct(request, sellerId);
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(okResponse("Product created successfully", product));
    }
    
    // PUT /products/{id} (seller only & must own)
    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductResponse>> updateProduct(
            @PathVariable String id,
            @Valid @RequestBody UpdateProductRequest request,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role
    ) {
        if (!"SELLER".equals(role)) {
            throw new ForbiddenException("Only sellers can update products.");
        }
        
        ProductResponse product = productService.updateProduct(id, request, sellerId);
        return ResponseEntity.ok(okResponse("Product updated successfully", product));
    }
    
    // DELETE /products/{id} (seller only & must own)
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteProduct(
            @PathVariable String id,
            @RequestHeader("X-USER-ID") String sellerId,
            @RequestHeader("X-USER-ROLE") String role
    ) {
        if (!"SELLER".equals(role)) {
            throw new ForbiddenException("Only sellers can delete products.");
        }
        
        productService.deleteProduct(id, sellerId);
        return ResponseEntity.ok(okResponse("Product deleted successfully", null));
    }
    
    // Helper to build ApiResponse consistently
    private <T> ApiResponse<T> okResponse(String message, T data) {
        return ApiResponse.<T>builder()
                .success(true)
                .message(message)
                .data(data)
                .build();
    }
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/controller/ProductController.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/controller/CategoryController.java ---
package com.buyone.productservice.controller;

import com.buyone.productservice.response.CategoryResponse;
import com.buyone.productservice.request.UpdateCategoryRequest;
import com.buyone.productservice.service.CategoryService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/categories")
@RequiredArgsConstructor
public class CategoryController {
    
    private final CategoryService categoryService;
    
    @GetMapping
    public ResponseEntity<List<CategoryResponse>> getAll() {
        return ResponseEntity.ok(categoryService.getAllCategories());
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<CategoryResponse> getOne(@PathVariable String id) {
        return ResponseEntity.ok(categoryService.getCategoryById(id));
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<CategoryResponse> updateCategory(
            @PathVariable String id,
            @Valid @RequestBody UpdateCategoryRequest request
    ) {
        CategoryResponse updated = categoryService.updateCategory(id, request);
        return ResponseEntity.ok(updated);
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCategory(@PathVariable String id) {
        categoryService.deleteCategory(id);
        return ResponseEntity.noContent().build();
    }
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/controller/CategoryController.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/model/Product.java ---
package com.buyone.productservice.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.math.BigDecimal;


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder

@Document(collection = "products")
public class Product {
    @Id
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer quantity;
    private String userId;
    private String categoryId;
    private java.util.List<String> images;
}-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/model/Product.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/model/Category.java ---
package com.buyone.productservice.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder

@Document("categories")
public class Category {
    @Id
    private String id;
    private String slug;
    private String name;
    private String icon;
    private String description;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/model/Category.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/ProductServiceApplication.java ---
package com.buyone.productservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProductServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ProductServiceApplication.class, args);
	}

}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/ProductServiceApplication.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/request/CreateProductRequest.java ---
package com.buyone.productservice.request;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import jakarta.validation.constraints.*;

import java.math.BigDecimal;

/**
 * DTO for product creation, validates all required/optional fields.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CreateProductRequest {
    
    @NotBlank(message = "Product name is required")
    @Size(min = 2, max = 100, message = "Product name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 500, message = "Description must be less than 500 characters")
    private String description;
    
    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = true, message = "Price must be non-negative")
    private BigDecimal price;
    
    @NotNull(message = "Quantity is required")
    @Min(value = 0, message = "Quantity must be zero or greater")
    private Integer quantity;
    
    private String categoryId;
    
    private java.util.List<String> images;

    // userId is NOT included here, it comes from JWT / header in the controller for security!
    // Add more fields as model extends, with corresponding validations
    
    // For example, for media/image in future:
    // private String mediaId;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/request/CreateProductRequest.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/request/UpdateCategoryRequest.java ---
// src/main/java/com/buyone/productservice/request/UpdateCategoryRequest.java
package com.buyone.productservice.request;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import jakarta.validation.constraints.NotBlank;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UpdateCategoryRequest {
    @NotBlank(message = "Category name is required")
    private String name;
    
    private String icon;
    private String description;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/request/UpdateCategoryRequest.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/request/UpdateProductRequest.java ---
package com.buyone.productservice.request;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import jakarta.validation.constraints.*;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdateProductRequest {
    
    @Size(min = 2, max = 100, message = "Product name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 500, message = "Description must be less than 500 characters")
    private String description;
    
    @DecimalMin(value = "0.0", inclusive = true, message = "Price must be non-negative")
    private BigDecimal price;
    
    @Min(value = 0, message = "Quantity must be zero or greater")
    private Integer quantity;
    
    private String categoryId;

    private java.util.List<String> images;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/request/UpdateProductRequest.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/service/ProductService.java ---
package com.buyone.productservice.service;

import com.buyone.productservice.request.CreateProductRequest;
import com.buyone.productservice.request.UpdateProductRequest;
import com.buyone.productservice.response.ProductResponse;

import java.util.List;

public interface ProductService {
    ProductResponse createProduct(CreateProductRequest request, String sellerId);
    ProductResponse getProductById(String id);
    List<ProductResponse> getAllProducts();
    ProductResponse updateProduct(String id, UpdateProductRequest request, String sellerId);
    void deleteProduct(String id, String sellerId);
    List<ProductResponse> getProductsBySeller(String sellerId); // for seller dashboard
}


// Methods should use DTOs for incoming and outgoing data (except for internal lookups).-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/service/ProductService.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/service/CategoryServiceImpl.java ---
package com.buyone.productservice.service;

import com.buyone.productservice.exception.ResourceNotFoundException;
import com.buyone.productservice.model.Category;
import com.buyone.productservice.repository.CategoryRepository;
import com.buyone.productservice.request.UpdateCategoryRequest;
import com.buyone.productservice.response.CategoryResponse;
import com.buyone.productservice.service.CategoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class CategoryServiceImpl implements CategoryService {
    
    private final CategoryRepository categoryRepository;
    
    @Override
    public List<CategoryResponse> getAllCategories() {
        return categoryRepository.findAll()
                .stream()
                .map(this::toResponse)
                .toList();
    }
    
    @Override
    public CategoryResponse getCategoryById(String id) {
        var category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found: " + id));
        return toResponse(category);
    }
    
    @Override
    public void deleteCategory(String id) {
        if (!categoryRepository.existsById(id)) {
            throw new ResourceNotFoundException("Category not found: " + id);
        }
        categoryRepository.deleteById(id);
    }
    
    @Override
    public CategoryResponse updateCategory(String id, UpdateCategoryRequest request) {
        Category cat = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found: " + id));
        cat.setName(request.getName());
        cat.setIcon(request.getIcon());
        cat.setDescription(request.getDescription());
        Category saved = categoryRepository.save(cat);
        return toResponse(saved);
    }
    
    private CategoryResponse toResponse(Category c) {
        return new CategoryResponse(
                c.getId(),
                c.getSlug(),
                c.getName(),
                c.getIcon(),
                c.getDescription()
        );
    }
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/service/CategoryServiceImpl.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/service/ProductServiceImpl.java ---
package com.buyone.productservice.service;

import com.buyone.productservice.model.Product;
import com.buyone.productservice.repository.ProductRepository;
import com.buyone.productservice.request.CreateProductRequest;
import com.buyone.productservice.request.UpdateProductRequest;
import com.buyone.productservice.response.ProductResponse;
import com.buyone.productservice.exception.ProductNotFoundException;
import com.buyone.productservice.exception.BadRequestException;
import com.buyone.productservice.exception.ConflictException;
import com.buyone.productservice.exception.ForbiddenException;
import com.buyone.productservice.event.ProductCreatedEvent;
import com.buyone.productservice.event.ProductUpdatedEvent;
import com.buyone.productservice.event.ProductDeletedEvent;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.kafka.core.KafkaTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ProductServiceImpl implements ProductService {
    
    private final ProductRepository productRepository;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    private static final Logger log = LoggerFactory.getLogger(ProductServiceImpl.class);
    
    
    @Value("${app.kafka.topic.product-created}")
    private String productCreatedTopic;
    @Value("${app.kafka.topic.product-updated}")
    private String productUpdatedTopic;
    @Value("${app.kafka.topic.product-deleted}")
    private String productDeletedTopic;
    
    public ProductServiceImpl(ProductRepository productRepository, KafkaTemplate<String, Object> kafkaTemplate) {
        this.productRepository = productRepository;
        this.kafkaTemplate = kafkaTemplate;
    }
    
    // Create Product (seller only, enforce at controller)
    @Override
    public ProductResponse createProduct(CreateProductRequest request, String sellerId) {
        
        // Example conflict check (duplicate product name for seller)
        if (productRepository.findByUserId(sellerId).stream()
                .anyMatch(p -> p.getName().equalsIgnoreCase(request.getName()))) {
            throw new ConflictException("Product name already exists for seller.");
        }
        
        Product product = Product.builder()
                .name(request.getName())
                .description(request.getDescription())
                .price(request.getPrice())
                .quantity(request.getQuantity())
                .userId(sellerId)
                .categoryId(request.getCategoryId())
                .images(request.getImages())
                .build();
        
        Product savedProduct = productRepository.save(product);
//        ProductCreatedEvent event = ProductCreatedEvent.builder()
//                .productId(savedProduct.getId())
//                .sellerId(sellerId)
//                .name(savedProduct.getName())
//                .price(savedProduct.getPrice())
//                .build();
        // Publish event
        // kafkaTemplate.send(productCreatedTopic, event)
        //         .whenComplete((result, ex) -> {
        //             if (ex != null) {
        //                 log.error("Failed to publish event", ex);
        //             } else {
        //                 log.info("Event published: " + event);
        //             }
        //         });
        return toProductResponse(savedProduct);
    }
    
    // Get single product by ID
    @Override
    public ProductResponse getProductById(String id) {
        return productRepository.findById(id)
                .map(this::toProductResponse)
                .orElseThrow(() ->
                        new ProductNotFoundException("Product not found with ID: " + id)
                );
    }
    
    // Get all products (consider pagination for production)
    // consider Pagination. (page,size) to reduce a massive call as this scales.
    @Override
    public List<ProductResponse> getAllProducts() {
        List<Product> products = productRepository.findAll();
        if (products.isEmpty()) {
            throw new ProductNotFoundException("No products found.");
        }
        return products.stream()
                .map(this::toProductResponse)
                .collect(Collectors.toList());
    }
    
    // Update product (seller only)
    @Override
    public ProductResponse updateProduct(String id, UpdateProductRequest request, String sellerId) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException("Cannot update ‚Äî Product not found with ID: " + id));
        // BUSINESS RULE:
        // Only owner (seller) can update this product
        if (!product.getUserId().equals(sellerId)) {
            throw new ForbiddenException("Unauthorized: You do not own this product");
        }
        
//        // Validate business logic on incoming changes
//        if (request.getPrice() != null && request.getPrice() < 0) {
//            throw new BadRequestException("Price must be non-negative.");
//        }
//        if (request.getQuantity() != null && request.getQuantity() < 0) {
//            throw new BadRequestException("Quantity must be zero or greater.");
//        }
        
        // Prevent changing to a name that already exists for same seller (conflict)
        if (request.getName() != null && !request.getName().equals(product.getName())) {
            List<Product> existing = productRepository.findByUserId(sellerId)
                    .stream()
                    .filter(p -> p.getName().equalsIgnoreCase(request.getName()) && !p.getId().equals(product.getId()))
                    .collect(Collectors.toList());
            if (!existing.isEmpty()) {
                throw new ConflictException("Product with name already exists for seller.");
            }
        }
        
        // Update fields if provided
        if (request.getName() != null) product.setName(request.getName());
        if (request.getDescription() != null) product.setDescription(request.getDescription());
        if (request.getPrice() != null) product.setPrice(request.getPrice());
        if (request.getQuantity() != null) product.setQuantity(request.getQuantity());
        if (request.getCategoryId() != null) product.setCategoryId(request.getCategoryId());
        if (request.getImages() != null) product.setImages(request.getImages());

        Product updatedProduct = productRepository.save(product);
//        ProductUpdatedEvent event = ProductUpdatedEvent.builder()
//                .productId(updatedProduct.getId())
//                .sellerId(sellerId)
//                .name(updatedProduct.getName())
//                .price(updatedProduct.getPrice())
//                .build();
        // kafkaTemplate.send(productUpdatedTopic, event)
        //         .whenComplete((result, ex) -> {
        //             if (ex != null) {
        //                 log.error("Failed to publish event", ex);
        //             } else {
        //                 log.info("Event published: " + event);
        //             }
        //         });
        return toProductResponse(updatedProduct);
    }
    
    // Delete product (seller only)
    @Override
    @Transactional
    public void deleteProduct(String id, String sellerId) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException("Cannot delete ‚Äî Product not found with ID: " + id));
        // BUSINESS RULE:
        // Only owner (seller) can delete this product
        if (!product.getUserId().equals(sellerId)) {
            throw new ForbiddenException("Unauthorized: You do not own this product");
        }
        productRepository.deleteById(id);
        
        ProductDeletedEvent event = ProductDeletedEvent.builder()
                .productId(product.getId())
                .sellerId(sellerId)
                .build();
         kafkaTemplate.send(productDeletedTopic, event)
                 .whenComplete((result, ex) -> {
                     if (ex != null) {
                         log.error("Failed to publish event", ex);
                     } else {
                         log.info("Event published: " + event);
                     }
                 });

    }
    
    // Get all products by seller (for seller dashboard)
    @Override
    public List<ProductResponse> getProductsBySeller(String sellerId) {
        List<Product> products = productRepository.findByUserId(sellerId);
        // Do NOT throw on empty; just map to DTOs
        // if (products.isEmpty()) {
        //     throw new ProductNotFoundException("No products found for seller: " + sellerId);
        // }
        return products.stream().map(this::toProductResponse).collect(Collectors.toList());
    }
    
    // Helper: Map Product entity to ProductResponse DTO
    private ProductResponse toProductResponse(Product product) {
        return ProductResponse.builder()
                .id(product.getId())
                .name(product.getName())
                .description(product.getDescription())
                .price(product.getPrice())
                .images(product.getImages())
                .quantity(product.getQuantity())
                .userId(product.getUserId()) // Correct getter
                .categoryId(product.getCategoryId())
                .build();
    }
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/service/ProductServiceImpl.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/service/CategoryService.java ---
package com.buyone.productservice.service;

import com.buyone.productservice.request.UpdateCategoryRequest;
import com.buyone.productservice.response.CategoryResponse;

import java.util.List;

public interface CategoryService {
    List<CategoryResponse> getAllCategories();
    CategoryResponse getCategoryById(String id);
    CategoryResponse updateCategory(String id, UpdateCategoryRequest request);
    void deleteCategory(String id);
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/service/CategoryService.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/ForbiddenException.java ---
package com.buyone.productservice.exception;

public class ForbiddenException extends RuntimeException {
    
    public ForbiddenException() {
        super();
    }
    
    public ForbiddenException(String message) {
        super(message);
    }
    
    public ForbiddenException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ForbiddenException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/ForbiddenException.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/ResourceNotFoundException.java ---
package com.buyone.productservice.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException() {
        super();
    }
    
    public ResourceNotFoundException(String message) {
        super(message);
    }
    
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ResourceNotFoundException(Throwable cause) {
        super(cause);
    }
}-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/ResourceNotFoundException.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/ProductNotFoundException.java ---
package com.buyone.productservice.exception;

public class ProductNotFoundException extends RuntimeException {
    public ProductNotFoundException() {
        super();
    }
    
    public ProductNotFoundException(String message) {
        super(message);
    }
    
    public ProductNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ProductNotFoundException(Throwable cause) {
        super(cause);
    }
}-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/ProductNotFoundException.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/ConflictException.java ---
package com.buyone.productservice.exception;

public class ConflictException extends RuntimeException {
    
    public ConflictException() {
        super();
    }
    
    public ConflictException(String message) {
        super(message);
    }
    
    public ConflictException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ConflictException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/ConflictException.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/GlobalExceptionHandler.java ---
package com.buyone.productservice.exception;

import com.buyone.productservice.response.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;

import jakarta.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // Helper for building consistent error responses
    private ResponseEntity<ErrorResponse> buildError(HttpStatus status, String message, String path) {
        ErrorResponse error = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(status.value())
                .error(status.getReasonPhrase())
                .message(message)
                .path(path)
                .build();
        return new ResponseEntity<>(error, status);
    }
    
    // 400: Bean validation (@Valid) errors
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex, HttpServletRequest request) {
        // Collects all field validation errors into a single string
        String message = ex.getBindingResult().getFieldErrors().stream()
                .map(err -> err.getField() + ": " + err.getDefaultMessage())
                .collect(Collectors.joining(", "));
        return buildError(HttpStatus.BAD_REQUEST, message, request.getRequestURI());
    }
    
    // 400: Custom bad request
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequest(BadRequestException ex, HttpServletRequest request) {
        return buildError(HttpStatus.BAD_REQUEST, ex.getMessage(), request.getRequestURI());
    }
    
    // 403: Forbidden (custom app-level)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbidden(ForbiddenException ex, HttpServletRequest request) {
        return buildError(HttpStatus.FORBIDDEN, ex.getMessage(), request.getRequestURI());
    }
    
    // 403: Spring Security's access denied
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        return buildError(HttpStatus.FORBIDDEN, "Access Denied: " + ex.getMessage(), request.getRequestURI());
    }
    
    // 404: Not found for product
    @ExceptionHandler(ProductNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleProductNotFound(ProductNotFoundException ex, HttpServletRequest request) {
        return buildError(HttpStatus.NOT_FOUND, ex.getMessage(), request.getRequestURI());
    }
    
    // 405: HTTP Method not allowed
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowed(HttpRequestMethodNotSupportedException ex, HttpServletRequest request) {
        return buildError(HttpStatus.METHOD_NOT_ALLOWED, "Method Not Allowed: " + ex.getMessage(), request.getRequestURI());
    }
    
    // 409: Conflict (e.g., duplicate product name)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflict(ConflictException ex, HttpServletRequest request) {
        return buildError(HttpStatus.CONFLICT, ex.getMessage(), request.getRequestURI());
    }
    
    // 500: Fallback for unhandled exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex, HttpServletRequest request) {
        // In production, log this exception instead of printing!
        ex.printStackTrace();
        String cause = ex.getCause() != null ? ex.getCause().toString() : "No root cause";
        String fullMessage = (ex.getMessage() != null ? ex.getMessage() : "Unexpected server error")
                + " [" + cause + "]";
        return buildError(HttpStatus.INTERNAL_SERVER_ERROR, fullMessage, request.getRequestURI());
    }
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/GlobalExceptionHandler.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/BadRequestException.java ---
package com.buyone.productservice.exception;

public class BadRequestException extends RuntimeException {
    public BadRequestException() {
        super();
    }
    
    public BadRequestException(String message) {
        super(message);
    }
    
    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public BadRequestException(Throwable cause) {
        super(cause);
    }
}-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/exception/BadRequestException.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/event/ProductDeletedEvent.java ---
package com.buyone.productservice.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductDeletedEvent {
    private String productId;
    private String sellerId;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/event/ProductDeletedEvent.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/event/ProductCreatedEvent.java ---
package com.buyone.productservice.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductCreatedEvent {
    private String productId;
    private String sellerId;
    private String name;
    private BigDecimal price;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/event/ProductCreatedEvent.java ---

--- FILE: backend/product-service/src/main/java/com/buyone/productservice/event/ProductUpdatedEvent.java ---
package com.buyone.productservice.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductUpdatedEvent {
    private String productId;
    private String sellerId;
    private String name;
    private BigDecimal price;
}
-e 
--- END FILE: backend/product-service/src/main/java/com/buyone/productservice/event/ProductUpdatedEvent.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/repository/UserRepository.java ---
package com.buyone.userservice.repository;

import com.buyone.userservice.model.User;
import com.buyone.userservice.model.Role;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.Optional;
import java.util.List;

public interface UserRepository extends MongoRepository<User, String> {
    Optional<User> findByEmail(String email);
    List<User> findByRole(Role role);
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/repository/UserRepository.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/response/UserResponse.java ---
package com.buyone.userservice.response;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import com.buyone.userservice.model.Role;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponse {
    private String id;
    private String name;
    private String email;
    private Role role;
    private String avatar;
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/response/UserResponse.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/response/LoginResponse.java ---
package com.buyone.userservice.response;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.Builder;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginResponse {
    private String message;
    private String token;
    private UserResponse user;
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/response/LoginResponse.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/response/ErrorResponse.java ---
package com.buyone.userservice.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Builder;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@Builder
public class ErrorResponse {
    private int status;
    private String error;
    private String message;
    private String path;
    private LocalDateTime timestamp;
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/response/ErrorResponse.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/config/SecurityConfig.java ---
package com.buyone.userservice.config;

import com.buyone.userservice.auth.JwtFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {
    private final JwtFilter jwtFilter;
    
    @Autowired
    public SecurityConfig(JwtFilter jwtFilter) {
        this.jwtFilter = jwtFilter;
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        //.requestMatchers(HttpMethod.OPTIONS, "/**").permitAll() // Allow CORS preflight
                        .requestMatchers(HttpMethod.POST, "/auth/login", "/auth/register").permitAll() // Open auth endpoints
                        .requestMatchers(HttpMethod.GET, "/api/users/{id}").permitAll() // Allow public access to get seller by ID
                        .requestMatchers("/actuator/health").permitAll()
                        .anyRequest().authenticated() // Everything else requires JWT
                )
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/config/SecurityConfig.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/JwtUtil.java ---
package com.buyone.userservice.auth;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;

@Component
public class JwtUtil {
    
    // Inject from app config/secrets in production!
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expirationMs}")
    private long jwtExpirationMs;
    
    private SecretKey getSecretKey() {
        return Keys.hmacShaKeyFor(jwtSecret.getBytes());
    }
    
    public String generateToken(String userId, String email, String role) {
        return Jwts.builder()
                .subject(email)
                .claim("id", userId)
                .claim("role", role)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + jwtExpirationMs))
                .signWith(getSecretKey())
                .compact();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(getSecretKey())
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            System.err.println("JWT Validation failed: " + e.getMessage());
            return false;
        }
    }
    
    public String extractEmail(String token) {
        Jws<Claims> claimsJws = Jwts.parser()
                .verifyWith(getSecretKey())
                .build()
                .parseSignedClaims(token);
        return claimsJws.getPayload().getSubject();
    }
    
    public String extractRole(String token) {
        Jws<Claims> claimsJws = Jwts.parser()
                .verifyWith(getSecretKey())
                .build()
                .parseSignedClaims(token);
        return claimsJws.getPayload().get("role", String.class);
    }
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/JwtUtil.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/AuthController.java ---
package com.buyone.userservice.auth;

import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;

import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.request.LoginRequest;
import com.buyone.userservice.response.LoginResponse;
import com.buyone.userservice.auth.AuthService;


@RestController
@RequestMapping("/auth")
public class AuthController {
    private final AuthService authService;
    
    public AuthController(AuthService authService) {
        this.authService = authService;
    }
    
    @PostMapping("/register")
    public ResponseEntity<UserResponse> register(@RequestBody @Valid RegisterUserRequest request) {
        UserResponse created = authService.register(request);
        return ResponseEntity.status(201).body(created); // "201 Created" on success
    }
    
    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestBody @Valid LoginRequest request) {
        LoginResponse response = authService.login(request); // includes token, message, and UserResponse
        return ResponseEntity.ok(response); // "200 OK" with login payload
    }
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/AuthController.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/AuthService.java ---
package com.buyone.userservice.auth;

import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.request.LoginRequest;
import com.buyone.userservice.response.LoginResponse;
import com.buyone.userservice.response.UserResponse;

public interface AuthService {
    UserResponse register(RegisterUserRequest registerRequest);
    LoginResponse login(LoginRequest loginRequest);
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/AuthService.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/JwtFilter.java ---
package com.buyone.userservice.auth;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.List;

@Component
public class JwtFilter extends OncePerRequestFilter {
    
    private final JwtUtil jwtUtil;
    
    public JwtFilter(JwtUtil jwtUtil) {
        this.jwtUtil = jwtUtil;
    }
    
    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {
        
        String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }
        
        String token = authHeader.substring(7);
        if (jwtUtil.validateToken(token)) {
            String email = jwtUtil.extractEmail(token);
            String role = jwtUtil.extractRole(token);
            
            List<GrantedAuthority> authorities =
                    List.of(new SimpleGrantedAuthority("ROLE_" + role.toUpperCase()));
            
            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                            email, null, authorities
                    );
            authentication.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request)
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        filterChain.doFilter(request, response);
    }

    // Skip auth endpoints
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/auth/login") || path.startsWith("/auth/register");
    }

}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/JwtFilter.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/AuthServiceImpl.java ---
package com.buyone.userservice.auth;

import com.buyone.userservice.model.User;
import com.buyone.userservice.repository.UserRepository;
import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.request.LoginRequest;
import com.buyone.userservice.response.LoginResponse;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.exception.BadRequestException;
import com.buyone.userservice.exception.ConflictException;
import com.buyone.userservice.exception.ResourceNotFoundException;
import com.buyone.userservice.exception.AuthException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class AuthServiceImpl implements AuthService {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;
    
    public AuthServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder, JwtUtil jwtUtil) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.jwtUtil = jwtUtil;
    }
    
    @Override
    public UserResponse register(RegisterUserRequest registerRequest) {
        // validate and check for duplicate email, etc.
        if (userRepository.findByEmail(registerRequest.getEmail()).isPresent()) {
            throw new ConflictException("Email already exists");
        }
        User user = User.builder()
                .name(registerRequest.getName())
                .email(registerRequest.getEmail())
                .password(passwordEncoder.encode(registerRequest.getPassword()))
                .role(registerRequest.getRole())
                .avatar(registerRequest.getAvatar())
                .build();
        userRepository.save(user);
        return new UserResponse(user.getId(), user.getName(), user.getEmail(), user.getRole(), user.getAvatar());
    }
    
    @Override
    public LoginResponse login(LoginRequest loginRequest) {
        User user = userRepository.findByEmail(loginRequest.getEmail())
                .orElseThrow(() -> new ResourceNotFoundException("No user found with email: " + loginRequest.getEmail()));
        if (!passwordEncoder.matches(loginRequest.getPassword(), user.getPassword())) {
            throw new AuthException("Invalid email or password");
        }
        String roleType = user.getRole().name(); // changing role (enum) to string
        String token = jwtUtil.generateToken(user.getId(),user.getEmail(), roleType);
        return new LoginResponse("Login successful", token,
                new UserResponse(user.getId(), user.getName(), user.getEmail(), user.getRole(), user.getAvatar()));
    }
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/auth/AuthServiceImpl.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/UserServiceApplication.java ---
package com.buyone.userservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class UserServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(UserServiceApplication.class, args);
	}

}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/UserServiceApplication.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/controller/UserController.java ---
package com.buyone.userservice.controller;

import com.buyone.userservice.model.Role;
import com.buyone.userservice.request.UpdateUserRequest;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.service.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.security.Principal;
import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    // ---------------------- //
    
    // GET /api/users/{id} - Find user by ID (admin/internal)
    @GetMapping("/{id}")
    public ResponseEntity<UserResponse> getUserById(@PathVariable String id) {
        UserResponse user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
    
    // GET /api/users - List all users (admin/internal)
    @GetMapping
    public ResponseEntity<List<UserResponse>> getAllUsers() {
        List<UserResponse> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }
    
    // GET /me - current user profile
    @GetMapping("/me")
    public ResponseEntity<UserResponse> getCurrentUser(Principal principal) {
        String email = principal.getName();
        UserResponse user = userService.getUserByEmail(email);
        return ResponseEntity.ok(user);
    }
    
    @GetMapping("/sellers")
    public ResponseEntity<List<UserResponse>> getSellers() {
        return ResponseEntity.ok(userService.getUsersByRole(Role.SELLER));
    }
    
    @GetMapping("/clients")
    public ResponseEntity<List<UserResponse>> getClients() {
        return ResponseEntity.ok(userService.getUsersByRole(Role.CLIENT));
    }
    
    // ---------------------- //
    
    // PUT /me - update current user profile
    @PutMapping("/me")
    public ResponseEntity<UserResponse> updateCurrentUser(
            Principal principal,
            @Valid @RequestBody UpdateUserRequest updateUserRequest) {
        String email = principal.getName();
        UserResponse updated = userService.updateUserByEmail(email, updateUserRequest);
        return ResponseEntity.ok()
            .header("X-Email-Update", "Email changes require admin privileges")
            .body(updated);
    }

    // PUT /api/users/{id} - Update user info (admin/internal)
    @PutMapping("/{id}")
    public ResponseEntity<UserResponse> updateUser(
            @PathVariable String id,
            @Valid @RequestBody UpdateUserRequest updateUserRequest) {
        UserResponse updated = userService.updateUser(id, updateUserRequest);
        return ResponseEntity.ok(updated);
    }
    
    // DELETE /api/users/{id} - Delete user by ID (admin/internal)
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable String id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}



-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/controller/UserController.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/model/User.java ---
package com.buyone.userservice.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Data               // shortcut to combining @Getter, @Setter, @ToString, and @EqualsAndHashCode
@NoArgsConstructor  // generates a constructor with no arguments (empty body).
@AllArgsConstructor // Generates a constructor with one argument for every field in the class.
@Builder            // implements Builder pattern
                    // User user = User.builder().name("Joon").email(j@k.kr").password("pw").build()

@Document(collection = "users")
public class User {
    @Id
    private String id;
    private String name;
    private String email;
    private String password;
    private Role role;
    private String avatar;
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/model/User.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/model/Role.java ---
package com.buyone.userservice.model;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;

public enum Role {
    CLIENT,
    SELLER;
    
    @JsonCreator
    public static Role fromString(String value) {
        if (value == null) return null;
        return Role.valueOf(value.trim().toUpperCase());
    }
    
    @JsonValue
    public String toValue() {
        return name();
    }
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/model/Role.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/request/UpdateUserRequest.java ---
package com.buyone.userservice.request;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import jakarta.validation.constraints.*;
import com.buyone.userservice.model.Role;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdateUserRequest {
    @Size(min = 2, max = 40, message = "Name must be between 2 and 40 characters")
    private String name;
    
    @Email(message = "Invalid email format")
    @Size(max = 100, message = "Email must be less than 100 characters")
    private String email; // Keep for admin update
    
    @Size(min = 8, max = 24, message = "Password must be between 8 and 24 characters")
    private String password;
    
    private Role role;
    private String avatar;
    // Add more as your model evolves
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/request/UpdateUserRequest.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/request/RegisterUserRequest.java ---
package com.buyone.userservice.request;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import jakarta.validation.constraints.*;
import com.buyone.userservice.model.Role;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RegisterUserRequest {
    
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 40, message = "Name must be between 2 and 40 characters")
    private String name;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    @Size(max = 100, message = "Email must be less than 100 characters")
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 8, max = 24, message = "Password must be between 8 and 24 characters")
    private String password;
    
    @NotNull(message = "Role is required")
    private Role role;

    private String avatar;
    // Optional: Add other fields if needed, with validations
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/request/RegisterUserRequest.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/request/LoginRequest.java ---
package com.buyone.userservice.request;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import jakarta.validation.constraints.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email address format")
    private String email;
    
    @NotBlank(message = "Password is required")
    private String password;
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/request/LoginRequest.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/service/UserService.java ---
package com.buyone.userservice.service;

import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.request.UpdateUserRequest;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.model.User;
import com.buyone.userservice.model.Role;

import java.util.List;
import java.util.Optional;

public interface UserService {
    // Creation
    UserResponse createUser(RegisterUserRequest request);
    
    // Queries for API (DTOs)
    UserResponse getUserById(String id);
    UserResponse getUserByEmail(String email);
    
    List<UserResponse> getAllUsers();
    List<UserResponse> getUsersByRole(Role role);
    
    // Updates
    UserResponse updateUser(String id, UpdateUserRequest request);              // admin/internal
    UserResponse updateUserByEmail(String email, UpdateUserRequest request);   // for /me
    
    // Internal lookups (entities, not exposed to controllers)
    Optional<User> getUserEntityByEmail(String email);
    User getUserEntityById(String id);
    
    // Deletion
    void deleteUser(String id);
}


// Methods should use DTOs for incoming and outgoing data (except for internal lookups).-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/service/UserService.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/service/UserServiceImpl.java ---
package com.buyone.userservice.service;

import com.buyone.userservice.model.User;
import com.buyone.userservice.model.Role;
import com.buyone.userservice.repository.UserRepository;
import com.buyone.userservice.request.RegisterUserRequest;
import com.buyone.userservice.request.UpdateUserRequest;
import com.buyone.userservice.response.UserResponse;
import com.buyone.userservice.exception.BadRequestException;
import com.buyone.userservice.exception.ConflictException;
import com.buyone.userservice.exception.ResourceNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class UserServiceImpl implements UserService {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }
    
    // Creation //
    @Override
    public UserResponse createUser(RegisterUserRequest request) {
        if (request.getEmail() == null || request.getEmail().isBlank()) {
            throw new BadRequestException("Email cannot be empty");
        }
        if (userRepository.findByEmail(request.getEmail()).isPresent()) {
            throw new ConflictException("Email already exists: " + request.getEmail());
        }
        if (request.getPassword() == null || request.getPassword().isBlank()) {
            throw new BadRequestException("Password cannot be empty");
        }
        
        User user = User.builder()
                .name(request.getName())
                .email(request.getEmail())
                .password(passwordEncoder.encode(request.getPassword()))
                .role(request.getRole())
                .avatar(request.getAvatar())
                .build();
        
        User savedUser = userRepository.save(user);
        return toUserResponse(savedUser);
    }

    
    // -------------------------- //
    
    // for DTOs
    
    @Override
    public UserResponse getUserById(String id) {
        return userRepository.findById(id)
                .map(this::toUserResponse)
                .orElseThrow(
                        () -> new ResourceNotFoundException("User not found with ID " + id)
                );
    }
    
    @Override
    public UserResponse getUserByEmail(String email) {
        if (email == null || email.isBlank()) {
            throw new BadRequestException("Email must not be empty");
        }
        return userRepository.findByEmail(email)
                .map(this::toUserResponse)
                .orElseThrow(() ->
                        new ResourceNotFoundException("No user found with email: " + email)
                );
    }
    
    @Override
    public List<UserResponse> getAllUsers() {
        List<User> users = userRepository.findAll();
        if (users.isEmpty()) {
            throw new ResourceNotFoundException("No users found");
        }
        return users.stream()
                .filter(u -> u.getEmail() != null && u.getRole() != null)
                .map(this::toUserResponse)
                .collect(Collectors.toList());
    }
    
    @Override
    public List<UserResponse> getUsersByRole(Role role) {
        return userRepository.findByRole(role)
                .stream()
                .map(this::toUserResponse)
                .collect(Collectors.toList());
    }
    
    
    // -------------------------- //
    
    // updates
    @Override
    public UserResponse updateUser(String id, UpdateUserRequest request) {
        User existingUser = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + id));
        if (request.getEmail() != null && userRepository.findByEmail(request.getEmail()).isPresent()
                && !request.getEmail().equals(existingUser.getEmail())) {
            throw new ConflictException("Email already exists: " + request.getEmail());
        }
        
        if (request.getName() != null ) {
            existingUser.setName(request.getName());
        }
        if (request.getEmail() != null) {
            existingUser.setEmail(request.getEmail());
        }
        if (request.getPassword() != null && !request.getPassword().isBlank()) {
            existingUser.setPassword(passwordEncoder.encode(request.getPassword()));
        }
        if (request.getRole() != null) {
            existingUser.setRole(request.getRole());
        }

        // Always set avatar from request (can be null to clear)
        existingUser.setAvatar(request.getAvatar()); // may be null -> clears avatar   
            
        User updatedUser = userRepository.save(existingUser);
        return toUserResponse(updatedUser);
    }
    
    @Override
    public UserResponse updateUserByEmail(String email, UpdateUserRequest request) {
        if (email == null || email.isBlank()) {
            throw new BadRequestException("Email must not be empty");
        }
        
        User existingUser = userRepository.findByEmail(email)
                .orElseThrow(() ->
                        new ResourceNotFoundException("No user found with email: " + email)
                );
        
        // Decide allowed fields for self-update (no role change, maybe no email change)
        if (request.getName() != null) {
            existingUser.setName(request.getName());
        }
        if (request.getPassword() != null && !request.getPassword().isBlank()) {
            existingUser.setPassword(passwordEncoder.encode(request.getPassword()));
        }
        existingUser.setAvatar(request.getAvatar()); // may be null -> clears avatar
        // if you want to allow email change via /me, handle it carefully & check uniqueness
        
        User updatedUser = userRepository.save(existingUser);
        return toUserResponse(updatedUser);
    }
    
    // -------------------------- //
    
    // for internal lookup
    @Override
    public Optional<User> getUserEntityByEmail(String email) {
        if (email == null || email.isBlank()) {
            throw new BadRequestException("Email must not be empty");
        }
        return userRepository.findByEmail(email);
    }
    
    @Override
    public User getUserEntityById(String id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + id));
    }
    
    // -------------------------- //
    
    // Deletion
    
    @Override
    @Transactional
    public void deleteUser(String id) {
        if (!userRepository.existsById(id)) {
            throw new ResourceNotFoundException("Cannot delete ‚Äî user not found with ID: " + id);
        }
        // Cascade deletes/logic for related entities if needed
        userRepository.deleteById(id);
    }
    
    // -------------------------- //
    
    // Mapping helper
    private UserResponse toUserResponse(User user) {
        return UserResponse.builder()
                .id(user.getId())
                .name(user.getName())
                .email(user.getEmail())
                .role(user.getRole())
                .avatar(user.getAvatar())
                .build();
    }
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/service/UserServiceImpl.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/ForbiddenException.java ---
package com.buyone.userservice.exception;

public class ForbiddenException extends RuntimeException {
    
    public ForbiddenException() {
        super();
    }
    
    public ForbiddenException(String message) {
        super(message);
    }
    
    public ForbiddenException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ForbiddenException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/ForbiddenException.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/ResourceNotFoundException.java ---
package com.buyone.userservice.exception;

public class ResourceNotFoundException extends RuntimeException {
    
    public ResourceNotFoundException() {
        super();
    }
    
    public ResourceNotFoundException(String message) {
        super(message);
    }
    
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ResourceNotFoundException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/ResourceNotFoundException.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/ConflictException.java ---
package com.buyone.userservice.exception;

public class ConflictException extends RuntimeException {
    
    public ConflictException() {
        super();
    }
    
    public ConflictException(String message) {
        super(message);
    }
    
    public ConflictException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ConflictException(Throwable cause) {
        super(cause);
    }
    
}-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/ConflictException.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/GlobalExceptionHandler.java ---
package com.buyone.userservice.exception;

import com.buyone.userservice.response.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;

import jakarta.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // Helper for building error responses
    private ResponseEntity<ErrorResponse> buildError(HttpStatus status, String message, String path) {
        ErrorResponse error = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(status.value())
                .error(status.getReasonPhrase())
                .message(message)
                .path(path)
                .build();
        return new ResponseEntity<>(error, status);
    }
    
    // 400: Bean validation (@Valid) errors
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex, HttpServletRequest request) {
        String message = ex.getBindingResult().getFieldErrors().stream()
                .map(err -> err.getField() + ": " + err.getDefaultMessage())
                .collect(Collectors.joining(", "));
        return buildError(HttpStatus.BAD_REQUEST, message, request.getRequestURI());
    }
    
    // 400: Bad request
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequest(BadRequestException ex, HttpServletRequest request) {
        return buildError(HttpStatus.BAD_REQUEST, ex.getMessage(), request.getRequestURI());
    }
    
    // 401: Unauthorized
    @ExceptionHandler(AuthException.class)
    public ResponseEntity<ErrorResponse> handleAuth(AuthException ex, HttpServletRequest request) {
        return buildError(HttpStatus.UNAUTHORIZED, ex.getMessage(), request.getRequestURI());
    }
    
    // 403: Forbidden
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbidden(ForbiddenException ex, HttpServletRequest request) {
        return buildError(HttpStatus.FORBIDDEN, ex.getMessage(), request.getRequestURI());
    }
    
    // 403: Authorization denied (Spring Security)
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAuthorizationDenied(AccessDeniedException ex, HttpServletRequest request) {
        return buildError(HttpStatus.FORBIDDEN, "Access Denied: " + ex.getMessage(), request.getRequestURI());
    }
    
    // 404: Not found
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex, HttpServletRequest request) {
        return buildError(HttpStatus.NOT_FOUND, ex.getMessage(), request.getRequestURI());
    }
    
    // 405: Method not allowed
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowed(HttpRequestMethodNotSupportedException ex, HttpServletRequest request) {
        return buildError(HttpStatus.METHOD_NOT_ALLOWED, "Method Not Allowed: " + ex.getMessage(), request.getRequestURI());
    }
    
    // 409: Conflict (duplicate resource)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflict(ConflictException ex, HttpServletRequest request) {
        return buildError(HttpStatus.CONFLICT, ex.getMessage(), request.getRequestURI());
    }
    
    // 500: Generic fallback
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex, HttpServletRequest request) {
        ex.printStackTrace();
        String cause = ex.getCause() != null ? ex.getCause().toString() : "No root cause";
        String fullMessage = (ex.getMessage() != null ? ex.getMessage() : "Unexpected server error")
                + " [" + cause + "]";
        return buildError(HttpStatus.INTERNAL_SERVER_ERROR, fullMessage, request.getRequestURI());
    }
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/GlobalExceptionHandler.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/AuthException.java ---
package com.buyone.userservice.exception;

public class AuthException extends RuntimeException {
    
    public AuthException() {
        super();
    }
    
    public AuthException(String message) {
        super(message);
    }
    
    public AuthException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public AuthException(Throwable cause) {
        super(cause);
    }
    
}
-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/AuthException.java ---

--- FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/BadRequestException.java ---
package com.buyone.userservice.exception;

public class BadRequestException extends RuntimeException {
    public BadRequestException() {
        super();
    }
    
    public BadRequestException(String message) {
        super(message);
    }
    
    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public BadRequestException(Throwable cause) {
        super(cause);
    }
}-e 
--- END FILE: backend/user-service/src/main/java/com/buyone/userservice/exception/BadRequestException.java ---

